{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（五）：ReactPackage 与 Native Module 详解","desc":"在创建 NativeModule 或 ViewManager 时，我们都得将它们添加到某个 ReactPackage 下。这是怎样的一种设计思想呢？从本节开始，我们由浅入深地分析 React Native 是如何使用 ReactPackage 的。","type":"md","link":"ReactNativeCode5md","create":"2019-02-18","filename":"ReactNativeCode5.md"},"content":"## 前言\n\n在创建 NativeModule 或 ViewManager 时，我们都得将它们添加到某个 ReactPackage 下。这是怎样的一种设计思想呢？\n\n我们先来看 ReactPackage 的注释：\n\nReactPackage 自身是一个接口，它的作用是向 Catalyst 框架提供额外的功能特性，主要包括：\n\n1.  注册新的原生模块\n2.  注册新的 JS 模块，能从原生模块中访问\n3.  注册自定义原生视图（View Manager），以及自定义事件类型\n4.  注册原生包资源，供 JS 调用\n\n在 ReactPackage 中实现了功能 1 和 3.\n\n从本节开始，我们由浅入深地分析 React Native 是如何使用 ReactPackage 的。\n\n## 分析入口\n\n首先我们从第一篇中讲到的，在 Android 中继承 React Native，MainActivity 的写法：\n\n```java\npublic class MainActivity extends Activity implements DefaultHardwareBackBtnHandler {\n\n    private ReactInstanceManager mReactInstanceManager;\n    private ReactRootView mReactRootView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mReactRootView = new ReactRootView(this);\n\n        mReactInstanceManager = ReactInstanceManager.builder()\n                .setApplication(getApplication())\n                .setBundleAssetName(\"index.android.bundle\")\n                .setJSMainModuleName(\"index.android\")\n                .addPackage(new MainReactPackage())\n                .setUseDeveloperSupport(BuildConfig.DEBUG)\n                .setInitialLifecycleState(LifecycleState.RESUMED)\n                .build();\n\n        mReactRootView.startReactApplication(mReactInstanceManager, \"Basic\", null);\n\n        setContentView(mReactRootView);\n    }\n```\n\n其中：\n\n-   这一步我们应当很熟悉了。如果不熟悉的话，请学习系列的第一篇文章\n-   我们关注其中的 ReactInstanceManager.builder 这一段\n-   在 .addPackage(new MainReactPackage()) 中我们添加了 MainReactPackage 这个包\n-   MainReactPackage 是 React Native 必须添加的 Package\n\n## ReactInstanceManager 内置包\n\nReactInstanceManager 通过 Builder 模式构建，我们对它已经很熟悉了，因此跳过 ReactInstanceManagerBuilder 直接来看 ReactInstanceManager。\n\n在 ReactInstanceManager 中，ReactPackage 存放在成员变量中：\n\n-   `List<ReactPackage> mPackages;`\n\n在 ReactInstanceManager 的构造函数中，ReactInstanceManager 也会自己向 mPackages 中添加几个包：\n\n-   CoreModulesPackage\n-   DebugCorePackage（可选）\n\n加上我们外面添加的 MainReactPackage 包，这样至少就有两个包会被一定添加的。\n\n## NativeModuleRegistry\n\n### 介绍\n\n前面都是向 mPackages 添加 Package，添加的包什么时候被使用呢？\n\n答案是在 ReactInstanceManager 的 createReactContext 方法中：\n\n```java\nNativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n```\n\n其中：\n\n-   NativeModuleRegistry 是什么呢？它的作用是存储 Native Modules\n-   实际方法都在 processPackages 中\n\n### processPackages\n\n因此接下来我们来看 processPackages 方法。\n\n首先方法签名：\n\n```java\nprivate NativeModuleRegistry processPackages(\n    ReactApplicationContext reactContext,\n    List<ReactPackage> packages,             // 我们的 mPackages\n    boolean checkAndUpdatePackageMembership) // false\n```\n\nNativeModuleRegistry 也是通过 Builder 方法构建的（NativeModuleRegistryBuilder）：\n\n```java\nNativeModuleRegistryBuilder nativeModuleRegistryBuilder = new NativeModuleRegistryBuilder(\n    reactContext,\n    this,\n    mLazyNativeModulesEnabled);\n```\n\n之后会对 packages 进行遍历，对每个 package，在内部会调用另一个同名方法：\n\n```java\nprocessPackage(reactPackage, nativeModuleRegistryBuilder);\n```\n\n我们进入这个方法来看，是如何处理这个包的。在方法内部，核心调用方法是：\n\n```java\nnativeModuleRegistryBuilder.processPackage(reactPackage);\n```\n\n我们看出，关键的逻辑都写在了 NativeModuleRegistryBuilder 中。因此进入 NativeModuleRegistryBuilder 的 processPackage 方法：\n\nNativeModuleRegistryBuilder 对 Package 有两种加载方式，一种是懒加载，一种是直接加载。在 processPackage 中通过一个 if else 结构来分别处理。\n\n在这里，我们来看直接加载的方式：\n\n```java\nList<NativeModule> nativeModules;\nif (reactPackage instanceof ReactInstancePackage) {\n    ReactInstancePackage reactInstancePackage = (ReactInstancePackage) reactPackage;\n    nativeModules = reactInstancePackage.createNativeModules(\n        mReactApplicationContext,\n        mReactInstanceManager);\n} else {\n    nativeModules = reactPackage.createNativeModules(mReactApplicationContext);\n}\nfor (NativeModule nativeModule : nativeModules) {\n    addNativeModule(nativeModule);\n}\n```\n\n其中：\n\n-   主要分为两步\n    -   调用 createNativeModules 创建 Native Module 实例\n    -   调用 addNativeModule\n\n在 addNativeModule 中：\n\nmModules 成员用于存放 Native Modules，它的类型是：\n\n```java\nMap<Class<? extends NativeModule>, ModuleHolder> mModules = new HashMap<>();\n```\n\n首先 addNativeModule 会进行一个去重操作，之后：\n\n```java\nnamesToType.put(name, type);\nModuleHolder moduleHolder = new ModuleHolder(nativeModule);\nmModules.put(type, moduleHolder);\n```\n\n这里的 ModuleHolder 是什么呢？它主要是用于懒加载功能的。在这里我们不做详细介绍，等以后有机会在 Native Module 的懒加载机制中再来介绍这一块。现在只要知道 ModuleHolder 中含有 Native Module 实例即可。\n\n最后将 nativeModule 按照类型 put 进 mModules 中。\n\n### 再次回到 createReactContext\n\n再次回到 createReactContext，如今我们已经有了 NativeModuleRegistry 实例：\n\n```java\nNativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n\nCatalystInstanceImpl.Builder catalystInstanceBuilder = new CatalystInstanceImpl.Builder()\n    .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())\n    .setJSExecutor(jsExecutor)\n    .setRegistry(nativeModuleRegistry)\n    .setJSBundleLoader(jsBundleLoader)\n    .setNativeModuleCallExceptionHandler(exceptionHandler);\n```\n\n其中：\n\n-   nativeModuleRegistry 传入了 CatalystInstanceImpl.Builder 的 Builder() 中。\n\n## CatalystInstanceImpl\n\n### 介绍\n\nCatalystInstanceImpl.Builder 很简单，我们直接看 CatalystInstanceImpl。\n\nnativeModuleRegistry 通过构造函数传入，保存在成员中：\n\n```java\nprivate final NativeModuleRegistry mNativeModuleRegistry;\n```\n\n### initializeBridge\n\n在构造函数中，将 mNativeModuleRegistry 传入 initializeBridge 方法中：\n\n```java\ninitializeBridge(\n    new BridgeCallback(this),\n    jsExecutor,\n    mReactQueueConfiguration.getJSQueueThread(),\n    mNativeModulesQueueThread,\n    mNativeModuleRegistry.getJavaModules(this),\n    mNativeModuleRegistry.getCxxModules());\n```\n\ninitializeBridge 的签名如下：\n\n```java\nprivate native void initializeBridge(\n    ReactCallback callback,\n    JavaScriptExecutor jsExecutor,\n    MessageQueueThread jsQueue,\n    MessageQueueThread moduleQueue,\n    Collection<JavaModuleWrapper> javaModules,\n    Collection<ModuleHolder> cxxModules);\n```\n\n它是一个 JNI 方法，因此我们转入 C++ 层的 ReactAndroid/src/main/jni/react/jni/CatalystInstanceImpl.cpp 的 CatalystInstanceImpl::initializeBridge。\n\n它的方法签名如下：\n\n```java\nvoid CatalystInstanceImpl::initializeBridge(\n    jni::alias_ref<ReactCallback::javaobject> callback,\n    // This executor is actually a factory holder.\n    JavaScriptExecutorHolder* jseh,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> jsQueue,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> nativeModulesQueue,\n    jni::alias_ref<jni::JCollection<JavaModuleWrapper::javaobject>::javaobject> javaModules,\n    jni::alias_ref<jni::JCollection<ModuleHolder::javaobject>::javaobject> cxxModules) {\n```\n\n我们可以对照一下，同一个对象，在 Java 侧与 C++ 的对应关系。\n\n这个方法首先对 nativeModulesQueue 建立一份在 C++ 侧的引用：\n\n```java\nmoduleMessageQueue_ = std::make_shared<JMessageQueueThread>(nativeModulesQueue);\n```\n\n之后调用：\n\n```java\nmoduleRegistry_ = std::make_shared<ModuleRegistry>(\n    buildNativeModuleList(\n        std::weak_ptr<Instance>(instance_),\n        javaModules,\n        cxxModules,\n        moduleMessageQueue_));\n```\n\n其中：\n\n-   NativeModule（定义在 ReactCommon/cxxreact/NativeModule.h） 是 C++ 侧存放 Native Modules 的类.\n-   基于 NativeModule 有派生类：\n    -   JavaNativeModule：ReactAndroid/src/main/jni/react/jni/JavaModuleWrapper.h\n    -   CxxNativeModule：ReactCommon/cxxreact/CxxNativeModule.h\n\n下面来看 buildNativeModuleList：\n\n```java\nstd::vector<std::unique_ptr<NativeModule>> buildNativeModuleList(\n    std::weak_ptr<Instance> winstance,\n    jni::alias_ref<jni::JCollection<JavaModuleWrapper::javaobject>::javaobject> javaModules,\n    jni::alias_ref<jni::JCollection<ModuleHolder::javaobject>::javaobject> cxxModules,\n    std::shared_ptr<MessageQueueThread> moduleMessageQueue) {\n  std::vector<std::unique_ptr<NativeModule>> modules;\n  if (javaModules) {\n    for (const auto& jm : *javaModules) {\n      modules.emplace_back(folly::make_unique<JavaNativeModule>(\n                     winstance, jm, moduleMessageQueue));\n    }\n  }\n  if (cxxModules) {\n    for (const auto& cm : *cxxModules) {\n      modules.emplace_back(folly::make_unique<CxxNativeModule>(\n                             winstance, cm->getName(), cm->getProvider(), moduleMessageQueue));\n    }\n  }\n  return modules;\n}\n```\n\n其中：\n\n-   modules 是一个 Vector，用于存放 NativeModule\n-   CxxModule 和 JavaModule 虽然是分开从 Java 层传过来的，但是在这里他们只是初始化方式不同，最终有合并放进了 modules 中\n\n我们主要来看对 javaModules 的初始化部分，也就是这一部分：\n\n```java\nfor (const auto& jm : *javaModules) {\n    modules.emplace_back(folly::make_unique<JavaNativeModule>(\n                    winstance, jm, moduleMessageQueue));\n}\n```\n\n在这里，我们将 `JavaModuleWrapper::javaobject` （jm) 作为参数传入 JavaNativeModule 的构造方法中。\n\n## JavaNativeModule\n\n### 介绍\n\nJavaNativeModule 声明在在 ReactAndroid/src/main/jni/react/jni/JavaModuleWrapper.h。\n\n我们来看它的成员变量：\n\n```java\nstd::weak_ptr<Instance> instance_;\njni::global_ref<JavaModuleWrapper::javaobject> wrapper_;\nstd::shared_ptr<MessageQueueThread> messageQueueThread_;\nstd::vector<folly::Optional<MethodInvoker>> syncMethods_;\n```\n\n其中：\n\n-   虽然不是完全明白，但是能看出个大概\n-   `instance_` 这个一定是 React Native 在 C++ 层的核心类\n-   `wrapper_` 这是我们的 Native Module（从 Java 层一层一层传进来不容易啊……）\n-   `messageQueueThread_` 对队列也有引用\n-   `syncMethods_` 暂时不知道是啥\n\n构造函数如下，保存各个成员：\n\n```java\nJavaNativeModule(\n    std::weak_ptr<Instance> instance,\n    jni::alias_ref<JavaModuleWrapper::javaobject> wrapper,\n    std::shared_ptr<MessageQueueThread> messageQueueThread)\n        : instance_(std::move(instance))\n        , wrapper_(make_global(wrapper))\n        , messageQueueThread_(std::move(messageQueueThread)) {}\n```\n\n### invoke\n\nJavaModule 中在 Java 侧定义的方法是如何触发的呢？\n\n答案在 JavaNativeModule::invoke 中（ReactAndroid/src/main/jni/react/jni/JavaModuleWrapper.cpp）：\n\n```java\nvoid JavaNativeModule::invoke(unsigned int reactMethodId, folly::dynamic&& params, int callId) {\n  messageQueueThread_->runOnQueue([this, reactMethodId, params=std::move(params), callId] {\n    static auto invokeMethod = wrapper_->getClass()->getMethod<void(jint, ReadableNativeArray::javaobject)>(\"invoke\");\n    #ifdef WITH_FBSYSTRACE\n    if (callId != -1) {\n      fbsystrace_end_async_flow(TRACE_TAG_REACT_APPS, \"native\", callId);\n    }\n    #endif\n    invokeMethod(\n      wrapper_,\n      static_cast<jint>(reactMethodId),\n      ReadableNativeArray::newObjectCxxArgs(std::move(params)).get());\n  });\n}\n```\n\n其中：\n\n-   从这里，我们知道了函数调用不是直接的，而是向线程队列中扔一个闭包\n-   reactMethodId 表示方法 id\n-   callId 表示调用 id\n-   params 表示参数\n-   我们来看闭包内部：\n    -   首先通过 `wrapper_=（ =jni::global_ref<JavaModuleWrapper::javaobject>` ）获取方法（invoke）\n    -   之后触发 invokeMethod\n\n我们再从 C++ 层网上看，触发 invokeMethod 最终执行的是 ReactAndroid/src/main/java/com/facebook/react/bridge/JavaModuleWrapper.java 的 invoke：\n\n```java\npublic void invoke(int methodId, ReadableNativeArray parameters) {\n    if (mMethods == null || methodId >= mMethods.size()) {\n        return;\n    }\n\n    mMethods.get(methodId).invoke(mJSInstance, parameters);\n}\n```\n\n其中：\n\n-   JSInstance 表示 JS 实例\n\n下面来到了 NativeModule.NativeMethod 的 invoke 方法：\n\n它是一个接口：\n\n```java\npublic interface NativeModule {\n  interface NativeMethod {\n    void invoke(JSInstance jsInstance, ReadableNativeArray parameters);\n    String getType();\n  }\n```\n\nJavaMethodWrapper 实现了这个接口。它的 invoke 方法核心逻辑如下：\n\n```java\n@Override\npublic void invoke(JSInstance jsInstance, ReadableNativeArray parameters) {\n    processArguments(); // 处理参数\n    mMethod.invoke(mModuleWrapper.getModule(), mArguments); // 调用方法，这是一个反射方法\n```\n\n其中：\n\n-   这个过程中的参数处理具体还挺复杂的，这里暂不展开\n-   简单来说就是两步，处理参数，之后通过反射触发方法\n-   使用反射可能会有性能问题\n\n至此，我们就梳理完成了，Native Module 中所定义的方法，是如何在 React Native 底层保存并调用的。\n\n## 问题：ReactMethodId 是哪来的？\n\n### 介绍\n\n在前面有一个问题，就是我们在触发 Native Module 方法时是通过 reactMethodId 来调用的，这个 id 是怎么生成的呢？\n\n### JavaModuleWrapper.findMethods\n\nNative Module 中的方法都使用 @ReactMethod 进行标注。\n\nJavaModuleWrapper.findMethods 中会处理这个注解。\n\n具体做法出，拿出被注解方法的 Method（我们前面 invoke 的那个）。\n\n最终封装成一个 JavaMethodWrapper，放进 JavaModuleWrapper 的 mMethods 中：\n\n```java\nprivate final ArrayList<NativeModule.NativeMethod> mMethods;\n```\n\n我们在回头来看 JavaModuleWrapper 的 invoke：\n\n```java\n  public void invoke(int methodId, ReadableNativeArray parameters) {\n    if (mMethods == null || methodId >= mMethods.size()) {\n      return;\n    }\n\n    mMethods.get(methodId).invoke(mJSInstance, parameters);\n  }\n}\n```\n\n所谓的 reactMethodId 实际上是方法在 mMethods 中的 index。\n\n### 这种实现的问题\n\nNativeModule 中所提供的方法（被 @ReactMethod 注解的方法），是在运行时通过反射扫描的。\n\n这样会导致性能降低，不过好在 NativeModule 在整个生命周期内只加载一次，因此问题不大。\n\n但是也架不住量大，如果 Package 太多，最起码在冷启动时也会稍微卡一下。\n\n我想这也是为啥，React Native 给 Native Module 做了懒加载，能环节不少这种的问题。\n\n如果要彻底优化消除这里反射的性能影响的话，可以通过注解处理器在编译时就生成好 mMethods，运行时就不用再扫描了，直接拿来用就行。\n\n## 小结\n\n在本文中，我们从 ReactPackage 入手，分析了 React Native 是如何处理 ReactPackage 的。\n\n同时以 ReactPackage 中的 Native Module 为准，分析了 Native Module 在 React Native 中是如何注册，如何在底层使用，以及如何被底层触发的。\n\n"},"path":"post/ReactNativeCode5md"}
