{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（八）：MessageQueueThread 消息队列","desc":"React Native 底层是由消息队列机制来驱动的，消息队列是 React Native 中一个非常重要的组成部分。在本文中，我们开始对消息队列的梳理。","type":"md","link":"ReactNativeCode8md","create":"2019-02-22","filename":"ReactNativeCode8.md"},"content":"## 前言\n\nReact Native 底层是由消息队列机制来驱动的，消息队列是 React Native 中一个非常重要的组成部分。在本文中，我们开始对消息队列的梳理。\n\n在开发 React Native 应用的时候，我们会遇到一种特殊卡顿，此时 UI 线程还是 60 帧，但是视觉上视图元素却卡住不动。出现这种情况的原因就是消息队列拥塞了。\n\n保持消息队列畅通，是 React Native 流畅体验的关键。\n\n消息队列所对应的类是 MessageQueueThread，它是 Java 侧的一个接口。它的实现类是 MessageQueueThreadImpl。\n\n不仅如此，MessageQueueThread 还有位于 C++ 侧的映射类：ReactAndroid/src/main/jni/react/jni/JMessageQueueThread.h。\n\n下面我们开始分别来看。\n\n## MessageQueueThread 接口\n\n位于 ReactAndroid/src/main/java/com/facebook/react/bridge/queue/MessageQueueThread.java\n\n它的作用是给线程添加 Looper，以供执行 Runnable。\n\n提供的能力包括：\n\n`void runOnQueue(Runnable runnable)`\n\n-   在线程的队列中运行 Runnable\n-   Runnable 将会加入队尾\n-   可以重复添加，不会去重\n\n`callOnQueue(final Callable<T> callable)`\n\n-   在线程队列中运行 Callable（java.util.concurrent.Callable）\n-   Runnable 将会加入队尾\n-   可以重复添加，不会去重\n\n`boolean isOnThread()`\n\n-   当前线程是否是 MessageQueueThread\n\n`void assertIsOnThread()`\n\n-   当前线程是否是 MessageQueueThread\n-   如果不是抛出异常\n\n`void assertIsOnThread(String message)`\n\n-   当前线程是否是 MessageQueueThread\n-   如果不是抛出异常\n\n`void quitSynchronous()`\n\n-   退出 MessageQueueThread\n-   若从 MessageQueueThread 调用，这会是线程做的最后一件事\n-   若从别的线程调用这个 MessageQueueThread 的 quitSynchronous 方法，那个别的线程将会被阻塞，直到完成退出\n\n## MessageQueueThreadImpl 类\n\n### 介绍\n\nMessageQueueThreadImpl 是 MessageQueueThread 接口的实现类。\n\nMessageQueueThread 有两类：\n\n-   运行在主线程的\n-   运行在后台线程的\n\n我们来看看他是怎么实现 MessageQueueThread 接口定义的功能的。\n\n### Looper Handler\n\nMessageQueueThreadImpl 的消息队列就是我们 Android 开发所熟知的 Looper Handler 机制：\n\n```java\nprivate MessageQueueThreadImpl(\n        String name,\n        Looper looper,\n        QueueThreadExceptionHandler exceptionHandler) {\n    mName = name;\n    mLooper = looper;\n    mHandler = new MessageQueueThreadHandler(looper, exceptionHandler);\n    mAssertionErrorMessage = \"Expected to be called from the '\" + getName() + \"' thread!\";\n}\n```\n\n从因此，runOnQueue 跟 callOnQueue 也是没什么悬念，就是想 mHandler 里面扔 Runnable（Callable 则是先用 Runnable 封一下再扔）:\n\n```java\npublic void runOnQueue(Runnable runnable) {\n    if (mIsFinished) {\n        FLog.w(\n            ReactConstants.TAG,\n            \"Tried to enqueue runnable on already finished thread: '\" + getName() +\n                \"... dropping Runnable.\");\n    }\n    mHandler.post(runnable);\n}\n```\n\nisOnThread 判断方式也是我们非常熟悉的：\n\n```java\npublic boolean isOnThread() {\n    return mLooper.getThread() == Thread.currentThread();\n}\n```\n\n### 构造方式\n\nMessageQueueThreadImpl 的构造方式是私有的，只能通过其对外暴露的 create 方法创建。\n\n我们先来看构造方法的签名：\n\n```java\npublic static MessageQueueThreadImpl create(\n    MessageQueueThreadSpec spec,\n    QueueThreadExceptionHandler exceptionHandler) {\n```\n\n它接收两个参数：\n\n-   MessageQueueThreadSpec 是一个配置类\n-   QueueThreadExceptionHandler 用于处理 Handler 异常\n\n### MessageQueueThreadSpec\n\nMessageQueueThreadImpl 在构造时通过 MessageQueueThreadSpec 指定构造参数。我们先来看下这个构造类。\n\n构造参数包含三个：\n\n-   ThreadType mThreadType：线程类型\n-   String mName：名称\n-   long mStackSize：栈大小，默认为 0，表示不指定大小\n\n其中 ThreadType 是一个枚举：\n\n```java\nprotected static enum ThreadType {\n    MAIN_UI,\n    NEW_BACKGROUND,\n}\n```\n\n它提供了3个静态方法，用于创建：\n\n-   MessageQueueThreadSpec newUIBackgroundTreadSpec(String name)\n-   MessageQueueThreadSpec newBackgroundThreadSpec(String name)\n-   MessageQueueThreadSpec newBackgroundThreadSpec(String name, long stackSize)\n\n### 具体构造\n\n下面我们回到 MessageQueueThreadImpl 的 create，看具体构造方式。\n\n首先在 create 方法中，根据 MessageQueueThreadSpec 指定的类型，执行对应的创建方法：\n\n```java\npublic static MessageQueueThreadImpl create(\n        MessageQueueThreadSpec spec,\n        QueueThreadExceptionHandler exceptionHandler) {\n    switch (spec.getThreadType()) {\n        case MAIN_UI:\n            return createForMainThread(spec.getName(), exceptionHandler);\n        case NEW_BACKGROUND:\n            return startNewBackgroundThread(spec.getName(), spec.getStackSize(), exceptionHandler);\n        default:\n            throw new RuntimeException(\"Unknown thread type: \" + spec.getThreadType());\n    }\n}\n```\n\n其中：\n\n-   我们注意到一点，栈大小只有 BackgroundThread 会用到\n\n### createForMainThread\n\ncreateForMainThread 内部的主要工作是：\n\n获取主线程 Looper：\n\n```java\nLooper mainLooper = Looper.getMainLooper();\n```\n\n创建 MessageQueueThreadImpl 实例：\n\n```java\nfinal MessageQueueThreadImpl mqt =\n    new MessageQueueThreadImpl(name, mainLooper, exceptionHandler);\n```\n\n指定线程优先级：\n\n```java\nProcess.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);\n```\n\n### startNewBackgroundThread\n\nstartNewBackgroundThread 的代码如下：\n\n```java\nprivate static MessageQueueThreadImpl startNewBackgroundThread(\n    final String name,\n    long stackSize,\n    QueueThreadExceptionHandler exceptionHandler) {\n    final SimpleSettableFuture<Looper> looperFuture = new SimpleSettableFuture<>();\n    Thread bgThread = new Thread(null,\n        new Runnable() {\n            @Override\n            public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);\n            Looper.prepare();\n\n            looperFuture.set(Looper.myLooper());\n            Looper.loop();\n            }\n        }, \"mqt_\" + name, stackSize);\n    bgThread.start();\n\n    Looper myLooper = looperFuture.getOrThrow();\n    return new MessageQueueThreadImpl(name, myLooper, exceptionHandler);\n}\n```\n\n其中：\n\n-   创建了一个线程\n-   运行线程\n-   取出线程的 Looper，创建 MessageQueueThreadImpl 实例\n\n## ReactQueueConfiguration 接口\n\nMessageQueueThreadImpl.create 方法是创建 createForMainThread 的入口。我们顺着入口向外，看看哪里调用它，来创建消息队列。\n\n结果我们找到了 ReactQueueConfiguration 接口。这个接口是 React Native 中关于线程的设置类，它明确说明了在 React Native 中有三条消息队列线程：\n\n1.  UI Queue Thread：标准 Android UI 主线程，不可设置\n2.  Native Modules Queue Thread：native module 被调用的线程和 Looper\n3.  JS Queue Thread：JS 执行所在的线程和 Looper\n\n## ReactQueueConfigurationImpl 类\n\n### 介绍\n\nReactQueueConfigurationImpl 是 ReactQueueConfiguration 的实现类。\n\n它包含三个成员：\n\n```java\nprivate final MessageQueueThreadImpl mUIQueueThread;\nprivate final MessageQueueThreadImpl mNativeModulesQueueThread;\nprivate final MessageQueueThreadImpl mJSQueueThread;\n```\n\n再看 ReactQueueConfigurationImpl 的构造函数：\n\n```java\nprivate ReactQueueConfigurationImpl(\n        MessageQueueThreadImpl uiQueueThread,\n        MessageQueueThreadImpl nativeModulesQueueThread,\n        MessageQueueThreadImpl jsQueueThread) {\n    mUIQueueThread = uiQueueThread;\n    mNativeModulesQueueThread = nativeModulesQueueThread;\n    mJSQueueThread = jsQueueThread;\n}\n```\n\n构造函数也是私有的，通过对外暴露一个 create 方法来创建。\n\n### ReactQueueConfigurationImpl.create\n\ncreate 方法的签名为：\n\n```java\npublic static ReactQueueConfigurationImpl create(\n    ReactQueueConfigurationSpec spec,\n    QueueThreadExceptionHandler exceptionHandler) {\n```\n\n首先，创建一个 Map，key 是 spec，value 是线程：\n\n```java\nMap<MessageQueueThreadSpec, MessageQueueThreadImpl> specsToThreads = MapBuilder.newHashMap();\n```\n\n创建主线程队列：\n\n```java\nMessageQueueThreadSpec uiThreadSpec = MessageQueueThreadSpec.mainThreadSpec();\nMessageQueueThreadImpl uiThread =\n    MessageQueueThreadImpl.create(uiThreadSpec, exceptionHandler);\nspecsToThreads.put(uiThreadSpec, uiThread);\n```\n\n创建 js 线程队列：\n\n```java\nMessageQueueThreadImpl jsThread = specsToThreads.get(spec.getJSQueueThreadSpec());\nif (jsThread == null) {\n    jsThread = MessageQueueThreadImpl.create(spec.getJSQueueThreadSpec(), exceptionHandler);\n}\n```\n\n创建 Native Module 线程队列：\n\n```java\nMessageQueueThreadImpl nativeModulesThread = \n    specsToThreads.get(spec.getNativeModulesQueueThreadSpec());\nif (nativeModulesThread == null) {\n    nativeModulesThread =\n        MessageQueueThreadImpl.create(spec.getNativeModulesQueueThreadSpec(), exceptionHandler);\n}\n```\n\n最后创建实例并返回：\n\n```java\nreturn new ReactQueueConfigurationImpl(\n    uiThread,\n    nativeModulesThread,\n    jsThread);\n```\n\n## CatalystInstanceImpl\n\n### 介绍\n\nReactQueueConfigurationImpl 在哪里被使用呢？答案是 CatalystInstanceImpl。我们又来到了这个重要的类。\n\nReactQueueConfigurationImpl 是它的一个成员：\n\n    private final ReactQueueConfigurationImpl mReactQueueConfiguration;\n\n### 使用\n\nCatalystInstanceImpl 具体是如何使用 ReactQueueConfigurationImpl 的呢？\n\n首先在 CatalystInstanceImpl 的构造方法中，创建 ReactQueueConfigurationImpl 实例：\n\n```java\nmReactQueueConfiguration = ReactQueueConfigurationImpl.create(\n    reactQueueConfigurationSpec,\n    new NativeExceptionHandler());\n```\n\n我们现在知道，这句方法调用完成后，三条消息队列线程就都已经创建（主线程不用创建）好了。\n\n之后 CatalystInstanceImpl 取出了 Native Thread，存入 mNativeModulesQueueThread 成员：\n\n```java\nmNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();\n```\n\n之后，用 mReactQueueConfiguration 创建的线程来初始化 Bridge：\n\n```java\ninitializeBridge(\n    new BridgeCallback(this),\n    jsExecutor,\n    mReactQueueConfiguration.getJSQueueThread(),\n    mNativeModulesQueueThread,\n    mNativeModuleRegistry.getJavaModules(this),\n    mNativeModuleRegistry.getCxxModules());\n```\n\n其中，initializeBridge 是一个 C++ 层的方法，不在我们今天的研究范围，先略过。\n\n在这里我们只要知道，ReactQueueConfigurationImpl 通过创建的线程，被成功地分发出去，在 React Native 的各处被使用起来即可。\n\n## ReactContext\n\n在 React Native 中还有一个重要的类持有这三条消息队列线程，那就是 ReactContext。\n\n我们在《React Native 中的各种 Context》中曾经说到过他。\n\n我们再来看下它的 initializeWithInstance 方法如下：\n\n```java\npublic void initializeWithInstance(CatalystInstance catalystInstance) {\n    if (catalystInstance == null) {\n        throw new IllegalArgumentException(\"CatalystInstance cannot be null.\");\n    }\n    if (mCatalystInstance != null) {\n        throw new IllegalStateException(\"ReactContext has been already initialized\");\n    }\n\n    mCatalystInstance = catalystInstance;\n\n    ReactQueueConfiguration queueConfig = catalystInstance.getReactQueueConfiguration();\n    mUiMessageQueueThread = queueConfig.getUIQueueThread();\n    mNativeModulesMessageQueueThread = queueConfig.getNativeModulesQueueThread();\n    mJSMessageQueueThread = queueConfig.getJSQueueThread();\n}\n```\n\n其中：\n\n-   保存了 mCatalystInstance 对象\n-   保存了 mUiMessageQueueThread 和 mJSMessageQueueThread\n\ninitializeWithInstance 是在哪里创建的呢？这个请看前文，已经分析地很透彻了。\n\n## C++ 侧\n\n### 介绍\n\nMessageQueueThread 这个类的复杂之处在于，不仅 Java 侧会调用它，C++ 侧也会调用它。\n\n在本节中我们分析 C++ 侧的消息队列线程。\n\n### MessageQueueThread 接口对应 C++ 类\n\nJava 层的 MessageQueueThread 也有对应的 C++ 类，也叫 MessageQueueThread，位于 ReactCommon/cxxreact/MessageQueueThread.h。\n\n```c++\nclass MessageQueueThread {\n public:\n  virtual ~MessageQueueThread() {}\n  virtual void runOnQueue(std::function<void()>&&) = 0;\n  // runOnQueueSync and quitSynchronous are dangerous.  They should only be\n  // used for initialization and cleanup.\n  virtual void runOnQueueSync(std::function<void()>&&) = 0;\n  // Once quitSynchronous() returns, no further work should run on the queue.\n  virtual void quitSynchronous() = 0;\n};\n```\n\n我们可以看到完全一致。\n\n但是我们可以看出，这个类只是一个普通的 C++ 类，没有用到 fbjni 的那一套，怎么映射的呢？\n\n映射类在 JavaMessageQueueThread，位于 ReactAndroid/src/main/jni/react/jni/JMessageQueueThread.h：\n\n```c++\nclass JavaMessageQueueThread : public jni::JavaClass<JavaMessageQueueThread> {\npublic:\n  static constexpr auto kJavaDescriptor = \"Lcom/facebook/react/bridge/queue/MessageQueueThread;\";\n};\n```\n\n奇怪？怎么一个类拆两边写呢？没关系，还有一个 JMessageQueueThread 将两者厝合起来：\n\n```c++\nclass JMessageQueueThread : public MessageQueueThread {\npublic:\n  JMessageQueueThread(alias_ref<JavaMessageQueueThread::javaobject> jobj);\n\n  /**\n   * Enqueues the given function to run on this MessageQueueThread.\n   */\n  void runOnQueue(std::function<void()>&& runnable) override;\n\n  /**\n   * Synchronously executes the given function to run on this\n   * MessageQueueThread, waiting until it completes.  Can be called from any\n   * thread, but will block if not called on this MessageQueueThread.\n   */\n  void runOnQueueSync(std::function<void()>&& runnable) override;\n\n  /**\n   * Synchronously quits the current MessageQueueThread. Can be called from any thread, but will\n   * block if not called on this MessageQueueThread.\n   */\n  void quitSynchronous() override;\n\n  JavaMessageQueueThread::javaobject jobj() {\n    return m_jobj.get();\n  }\n\nprivate:\n  global_ref<JavaMessageQueueThread::javaobject> m_jobj;\n};\n```\n\n看到这里我们明白了，原来使用了一个代理模式。\n\n其中有一点就要注意，JMessageQueueThread 这个类是 C++ 层所使用的消息队列线程，我们只需要认准他就可以了。\n\nReactAndroid/src/main/jni/react/jni/JMessageQueueThread.cpp 中对各个方法的实现我们不再赘述。都是在 C++ 如何通过 fbjni 操纵 Java 对象，感兴趣的可以看看。\n\n### JMessageQueueThread 在哪里使用\n\nC++ 层的 JMessageQueueThread 在哪里使用呢？在 C++ 层的 CatalystInstanceImpl 中。\n\n首先，CatalystInstanceImpl 有一个成员，持有 Native Module Thread：\n\n```c++\nstd::shared_ptr<JMessageQueueThread> moduleMessageQueue_;\n```\n\n在 CatalystInstanceImpl 的 initializeBridge 时，它会将 Native Module Thread 保存下来：\n\n```c++\nmoduleMessageQueue_ = std::make_shared<JMessageQueueThread>(nativeModulesQueue);\n```\n\n同时在 CatalystInstanceImpl 的 initializeBridge 中，也会把 JS Thread 传给 Instance 类：\n\n```c++\ninstance_->initializeBridge(\n    folly::make_unique<JInstanceCallback>(\n    callback,\n    moduleMessageQueue_),\n    jseh->getExecutorFactory(),\n    folly::make_unique<JMessageQueueThread>(jsQueue),\n    moduleRegistry_);\n```\n\nInstance 还记得是什么吗？（如果忘了参见前面的文章《C++ 侧的 Instance 类》），可以将它理解为 JavaScript 运行时。\n\n## Instance 中的消息队列\n\n### 介绍\n\n下面我们聚焦于 Instance，因为他是 JS 运行时，而我们刚刚梳理到把消息队列传入。在本节中，我们就来看运行时是如何与消息队列产生作用的。\n\n### Instance::initializeBridge\n\n在 Instance::initializeBridge 中，把 jsQueue 封装成 NativeToJsBridge 保存下来：\n\n```c++\nvoid Instance::initializeBridge(\n    std::unique_ptr<InstanceCallback> callback,\n    std::shared_ptr<JSExecutorFactory> jsef,\n    std::shared_ptr<MessageQueueThread> jsQueue,\n    std::shared_ptr<ModuleRegistry> moduleRegistry) {\n  callback_ = std::move(callback);\n  moduleRegistry_ = std::move(moduleRegistry);\n\n  jsQueue->runOnQueueSync([this, &jsef, jsQueue]() mutable {\n    nativeToJsBridge_ = folly::make_unique<NativeToJsBridge>(\n        jsef.get(), moduleRegistry_, jsQueue, callback_);\n\n    std::lock_guard<std::mutex> lock(m_syncMutex);\n    m_syncReady = true;\n    m_syncCV.notify_all();\n  });\n\n  CHECK(nativeToJsBridge_);\n}\n```\n\n其中：\n\n-   `nativeToJsBridge_` 这个成员暂时可以看做是消息队列线程了。\n-   Instance 的很多功能：注册 Bundle、调用 JS 方法，都是通过 `nativeToJsBridge_` 来实现的\n\nInstance 与 `nativeToJsBridge_` 的交互，这是 React Native 中很重要的一个机制，在本文中受限于篇幅，我们点到为止，在后面的文章中再详细介绍这一过程。\n\n## 小结\n\n在本文中，我们介绍了消息队列线程的：\n\n1.  实现原理\n2.  创建\n3.  在 React Native 中的位置\n4.  在 C++ 层的映射关系\n5.  Instance 与消息队列的核心交互为主（引出问题）\n\n"},"path":"post/ReactNativeCode8md"}
