{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（十三）：View 是如何创建的","desc":"在上一篇中我们学习了 Yoga，这为分析 React Native 的视图层打了很好的基础。在本篇中我们分析一个 View 在 JavaScript 中写下，是如何被展示成 Android 原生的 View 的。","type":"md","link":"ReactNativeCode13md","create":"2019-03-27","filename":"ReactNativeCode13.md"},"content":"## 前言\n\n在上一篇中我们学习了 Yoga，这为分析 React Native 的视图层打了很好的基础。在本篇中我们分析一个 View 在 JavaScript 中写下，是如何被展示成 Android 原生的 View 的。\n\n首先我们在 React Native 应用的 JavaScript 组件中定义一个简单的组件：\n\n```js\nexport default () => {\n    return <View style={{\n        backgroundColor: 'pink',\n        width: 200, \n        height: 200}}/>        \n}\n```\n\n这个组件会经由 JS → Native Bridge 转换为一下消息：\n\n```\nUIManager.createView([343,\"RCTView\",31,{\"backgroundColor\":-16181,\"width\":200,\"height\":200}])\n```\n\n其中：\n\n- Bridge message 中包含的属性就是我们在 JavaScript 中定义的属性\n\n## UIManagerModule.createView\n\n这条 message 最终会触发到 com.facebook.react.uimanager.UIManagerModule#createView 方法，它的参数签名为：\n\n```java\npublic void createView(int tag, String className, int rootViewTag, ReadableMap props) {\n```\n\n各个参数的值为：\n\n| 参数        | 值                                                           |\n| ----------- | ------------------------------------------------------------ |\n| tag         | 343                                                          |\n| className   | RCTView                                                      |\n| rootViewTag | 31                                                           |\n| props       | { NativeMap: {\"height\":200,\"width\":200,\"backgroundColor\":-16181} } |\n\n其中：\n\n- tag 与 rootViewTag 与前面 message 中的值是一致的\n\n## UIImplementation.createView\n\nUIManagerModule.createView 会继续调用 com.facebook.react.uimanager.UIImplementation#createView，它的方法签名与前者一致：\n\n```java\npublic void createView(int tag, String className, int rootViewTag, ReadableMap props) {\n```\n\n这里面这些参数都有什么作用呢？在我们继续分析的过程中会一一揭晓。\n\n下面我们来看在这个方法中都做了哪些事情：\n\n### 创建 ReactShadowNode\n\n首先会创建 ReactShadowNode：\n\n```java\nReactShadowNode cssNode = createShadowNode(className);\nReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootViewTag);\n```\n\n其中：\n\n- className 是 `RCTView`，UIImplementation 会用它从 mViewManagers 找出已经注册的 ViewManager，并执行这个 Manager 的 createShadowNodeInstance 方法\n- 在本例中实际调用的是 com.facebook.react.uimanager.ViewGroupManager#createShadowNodeInstance\n- rootViewTag 是什么呢？它是每个节点的标识，在 UIImplementation 中 mShadowNodeRegistry 是盛放所有 Node 的地方。可以将 mShadowNodeRegistry 看做一个数组，将 rootViewTag 看做数组的 index，通过 index 向数组中获取 ReactShadowNode，在上面代码中获取到的是跟布局的 Node\n\n之后对创建的新节点进行一些设置：\n\n```java\n// 保存 tag\ncssNode.setReactTag(tag);\n// 保存类名\ncssNode.setViewClassName(className);\n// 保存父布局\ncssNode.setRootTag(rootNode.getReactTag());\n// 保存 ReactContext\ncssNode.setThemedContext(rootNode.getThemedContext());\n```\n\n当这些步骤都完成后，将新 node 添加到 mShadowNodeRegistry 中：\n\n```java\nmShadowNodeRegistry.addNode(cssNode);\n```\n\n之后保存 props 信息：\n\n```java\nReactStylesDiffMap styles = null;\nif (props != null) {\n    styles = new ReactStylesDiffMap(props);\n    cssNode.updateProperties(styles);\n}\n```\n\n### UIImplementation.handleCreateView\n\n之后会调用 handleCreateView 方法：\n\n```java\nprotected void handleCreateView(\n        ReactShadowNode cssNode,\n        int rootViewTag,\n        @Nullable ReactStylesDiffMap styles) {\n    if (!cssNode.isVirtual()) {\n        mNativeViewHierarchyOptimizer.handleCreateView(cssNode, cssNode.getThemedContext(), styles);\n    }\n}\n```\n\n其中：\n\n- 如果新 node 不是 virtual node(有实际对应的 Native View)，则会调用 mNativeViewHierarchyOptimizer 的 handleCreateView\n\n## NativeViewHierarchyOptimizer.handleCreateView\n\n在 NativeViewHierarchyOptimizer.handleCreateView 中也没有真正创建视图，而是向队列中入队一个操作：\n\n```java\nmUIViewOperationQueue.enqueueCreateView(\n    themedContext,\n    node.getReactTag(),\n    node.getViewClass(),\n    initialProps);\n```\n\n## UIViewOperationQueue\n\nUIViewOperationQueue 是一个任务队列，用于执行 JS batch bridge 中执行的指令。\n\n还记得我们操作 JS 侧的 BatchedBridge 时的用法吗？常用的方法是：\n\n- 创建一系列 message，如视图创建、属性更新\n- 调用 flushedQueue 方法\n- 在 JS 侧给我们的感觉是，一调 flushedQueue，前面的这些 message 就会批量执行\n\n在 Native 层，实现这个任务队列和批量执行的类想必已经猜到了，就是 UIViewOperationQueue。其中批量执行的方法对应于它的 flushPendingBatches 方法。\n\n### 成员变量\n\n下面先让我们看下 UIViewOperationQueue 的成员变量。\n\n| 成员变量                    | 类型                       | 说明               |\n| --------------------------- | -------------------------- | ------------------ |\n| mNativeViewHierarchyManager | NativeViewHierarchyManager | 布局相关的实际操作 |\n| mDispatchUIFrameCallback    | DispatchUIFrameCallback    | UI 更新回调        |\n| mOperations                 | `ArrayList<UIOperation>`   | 任务队列           |\n| mDispatchUIRunnables        | `ArrayList<Runnable>`      | 积攒的一批一批任务 |\n\n### UIViewOperationQueue.enqueueCreateView\n\nenqueueCreateView 方法会创建一个 CreateViewOperation，并插入 mOperations 中。\n\n我们来看下 CreateViewOperation 的代码：\n\n```java\nprivate final class CreateViewOperation extends ViewOperation {\n\n    private final ThemedReactContext mThemedContext;\n    private final String mClassName;\n    private final @Nullable ReactStylesDiffMap mInitialProps;\n\n    public CreateViewOperation(\n        ThemedReactContext themedContext,\n        int tag,\n        String className,\n        @Nullable ReactStylesDiffMap initialProps) {\n            super(tag);\n            mThemedContext = themedContext;\n            mClassName = className;\n            mInitialProps = initialProps;\n            Systrace.startAsyncFlow(Systrace.TRACE_TAG_REACT_VIEW, \"createView\", mTag);\n    }\n\n    @Override\n    public void execute() {\n        Systrace.endAsyncFlow(Systrace.TRACE_TAG_REACT_VIEW, \"createView\", mTag);\n        mNativeViewHierarchyManager.createView(\n            mThemedContext,\n            mTag,\n            mClassName,\n            mInitialProps);\n    }\n}\n```\n\n其中：\n\n- 需要核心关注的是 execute 方法。任务队列在实际执行中会调用它，在内部通过 mNativeViewHierarchyManager 时间真正的视图创建操作\n\n## NativeViewHierarchyManager.createView\n\n下面我们就来看是如何真正创建 View 的。\n\n```java\n// 取出 ViewManager\nViewManager viewManager = mViewManagers.get(className);\n\n// 创建视图\n// 实际调用 com.facebook.react.views.view.ReactViewManager#createViewInstance\nView view = viewManager.createView(themedContext, mJSResponderHandler);\n\n// 保存视图\n// 还是通过 tag 关联，现在跟 tag 关联的有 ReactShadowNode 和 View\nmTagsToViews.put(tag, view);\n// viewManager 和 tag 关联\nmTagsToViewManagers.put(tag, viewManager);\n\n// 用 Android id 来保存 React Node Tag\nview.setId(tag);\n\n// 更新 Props\nif (initialProps != null) {\n    viewManager.updateProperties(view, initialProps);\n}\n```\n\n在这里问一个问题：**经过上面的代码后，我们创建的这个 View 会出现在屏幕上吗？**\n\n答案是并没有，我们虽然创建了 View 的实例，但是它还并没有被摆到屏幕上。\n\n那么在哪里被摆到屏幕上呢？在此我们知道肯定会有一个统一的地方，统一的时机，来遍历视图树，将 View 摆放到正确的位置上。\n\n## manageChildren message\n\n让我们再回到 JS → Native Bridge 上面，前面我们分析了 UIManager.createView 消息的解析。\n\n当绘制一个新 React 组件时，会创建多条 UIManager.createView 和 UIManager.setChildren 命令。\n\n在这些描述绘制的 message 发完后，最后会发一条 manageChildren 消息：\n\n```\nUIManager.manageChildren([209,[],[],[299],[1],[]])\n```\n\n这条消息会触发最终的页面绘制。\n\n这条消息将会触发到 com.facebook.react.uimanager.UIManagerModule#manageChildren 方法。\n\n它的方法签名如下：\n\n```java\npublic void manageChildren(\n    int viewTag,\n    @Nullable ReadableArray moveFrom,\n    @Nullable ReadableArray moveTo,\n    @Nullable ReadableArray addChildTags,\n    @Nullable ReadableArray addAtIndices,\n    @Nullable ReadableArray removeFrom) {\n```\n\n结合文档和前面的 message log，我们来看各个参数的作用：\n\n| 参数名称     | 值    | 作用                                         |\n| ------------ | ----- | -------------------------------------------- |\n| viewTag      | 209   | 父 View 的 Tag                               |\n| moveFrom     | []    | 父 View 中要移出的视图                       |\n| moveTo       | []    | 与 moveFrom 已启用，移出后放到父 View 的序列 |\n| addChildTags | [299] | 要添加进入父 View 的视图                     |\n| addAtIndices | [1]   | 与 addChildTags 一起用，添加到的序列         |\n| removeFrom   | []    | 需要从父视图中删除的序列的视图               |\n\n从中我们可以得出结论，需要做的是向 209 中添加一个 tag 为 299 的 View。\n\n经过一段与前面相同的辗转（这里虽然带过，但是内部的内容很多，ShadowTree 的层级创建就是在这一过程中），最后会向任务队列中插入一个 ManageChildrenOperation：\n\n```java\nprivate final class ManageChildrenOperation extends ViewOperation {\n\n  private final @Nullable int[] mIndicesToRemove;\n  private final @Nullable ViewAtIndex[] mViewsToAdd;\n  private final @Nullable int[] mTagsToDelete;\n\n  public ManageChildrenOperation(\n      int tag,\n      @Nullable int[] indicesToRemove,\n      @Nullable ViewAtIndex[] viewsToAdd,\n      @Nullable int[] tagsToDelete) {\n    super(tag);\n    mIndicesToRemove = indicesToRemove;\n    mViewsToAdd = viewsToAdd;\n    mTagsToDelete = tagsToDelete;\n  }\n\n  @Override\n  public void execute() {\n    mNativeViewHierarchyManager.manageChildren(\n        mTag,\n        mIndicesToRemove,\n        mViewsToAdd,\n        mTagsToDelete);\n  }\n}\n\n```\n\n其中：最终执行的是 mNativeViewHierarchyManager.manageChildren，它会调用 ViewGroup 的 addView 方法，进行实际的 View 层级关联。\n\n## 结论\n\n本文是对 View 是如何创建的这个大过程的一个粗粒度的梳理，其中有很多步骤是不详尽的。其中有些过程可能梳理地不对，如有错误之处欢迎指正。\n\n在后续的文章中会逐渐细化这些过程。"},"path":"post/ReactNativeCode13md"}
