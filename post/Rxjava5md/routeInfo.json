{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"Maxiee 的 RxJava 学习指南 (5) - RxBinding","desc":"在上一篇中介绍了 RxBinding 的常见用法和实现原理. RxBinding 封装的控件远不止上一篇中介绍的那些, 因此这一篇中我们继续探索 RxBinding, 学习它对其他控件封装的使用.","type":"md","link":"Rxjava5md","create":"2017-07-25","filename":"Rxjava5.md"},"content":"## 介绍\n\n在上一篇中介绍了 RxBinding 的常见用法和实现原理. RxBinding 封装的控件远不止上一篇中介绍的那些, 因此这一篇中我们继续探索 RxBinding, 学习它对其他控件封装的使用.\n\n本篇是介绍 RxBinding 的最后一篇, 相信在学习完这两篇之后, 我们不仅能够使用 RxBinding 封装的控件, 对于我们自定义的视图, 因为学习过了原理, 我们也能实现自己的 Binding. 因此, 在下一篇中我们将转向下一个专题的学习.\n\n下面我们开始本篇的学习, 本篇所涉及的代码都位于 [MaxieeRxLearning](https://github.com/maxiee/MaxieeRxLearning), 建议先将这个项目 Clone 下来参照着学习.\n\n## RxRecyclerView\n\nRxBindings 提供了一个 `rxbinding-recyclerview-v7`, 顾名思义就是对 recyclerview 提供支持. 首先我们要导入依赖:\n\n```\ncompile 'com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0'\n```\n\nRxBindings 库的使用方法都是一样的: 我们先创建一个 View, 之后用 RxBindings 提供的方法网上一套, 就将 View 封装成为了一个 Observable, 就能订阅它的一些事件.\n\n这个库提供了两个封装: RxRecyclerView 对应 RecyclerView, RxRecyclerViewAdapter 对应 Adapter, 我们分别来看.\n\n### RxRecyclerView\n\nRxRecyclerView 一共提供了两个状态的观察:\n\n-   scrollStateChanges 滚动状态\n-   scrollEvents 滚动事件\n\n#### scrollStateChanges 滚动状态\n\n滚动状态定义在 RecyclerView 中:\n\n```java\n// RecyclerView 当前没有滚动\npublic static final int SCROLL_STATE_IDLE = 0;\n\n// RecyclerView 正在被拖动\npublic static final int SCROLL_STATE_DRAGGING = 1;\n\n// 手已经离开屏幕, RecyclerView 正在做动画移动到最终位置\npublic static final int SCROLL_STATE_SETTLING = 2;\n```\n\n订阅方式:\n\n```java\nRxRecyclerView\n        .scrollStateChanges(mRecyclerView)\n        .subscribe(scrollState -> {\n            Log.d(\"maxiee\", \"scrollState = \" + scrollState);\n        });\n```\n\n在 LogCat 中看到:\n\n```java\n07-18 15:34:51.580 D/maxiee: scrollState = 1\n07-18 15:34:51.614 D/maxiee: scrollState = 2\n07-18 15:34:52.281 D/maxiee: scrollState = 0\n07-18 15:34:53.863 D/maxiee: scrollState = 1\n07-18 15:34:53.896 D/maxiee: scrollState = 2\n07-18 15:34:54.130 D/maxiee: scrollState = 0\n```\n\n#### scrollEvents 滚动事件\n\n滚动事件是我们更常用的, 就要通过它的 dx 和 dy, 判断是像什么方向移动了:\n\n```\nRxRecyclerView.scrollEvents(mRecyclerView)\n        .subscribe(scroll -> {\n            Log.d(\"maxiee\", \"dx = \" + scroll.dx() + \", dy = \" + scroll.dy());\n        });\n```\n\nLogCat:\n\n```java\n07-18 15:37:59.208 D/maxiee: dx = 0, dy = 0\n07-18 15:38:01.169 D/maxiee: dx = 0, dy = 13\n07-18 15:38:01.180 D/maxiee: dx = 0, dy = 31\n07-18 15:38:01.204 D/maxiee: dx = 0, dy = 29\n07-18 15:38:01.213 D/maxiee: dx = 0, dy = 45\n07-18 15:38:01.239 D/maxiee: dx = 0, dy = 34\n07-18 15:38:01.247 D/maxiee: dx = 0, dy = 21\n```\n\n#### childAttachStateChangeEvents\n\n观察 child view 的 detached 状态, 当 LayoutManager 或者 RecyclerView 认为不再需要一个 child view 时, 会调用这个方法. 如果 child view 占用资源, 应当进行资源释放. 具体代码为:\n\n```java\nRxRecyclerView.childAttachStateChangeEvents(mRecyclerView).subscribe(event -> {\n    Button button = ((SimpleAdapter.ViewHolder) event.child().getTag()).mButton;\n    CharSequence text = button.getText();\n\n    if (event instanceof RecyclerViewChildAttachEvent) {\n        Log.d(\"maxiee\", \"attach \" + text);\n        return;\n    }\n\n    if (event instanceof RecyclerViewChildDetachEvent) {\n        Log.d(\"maxiee\", \"detach \" + text);\n        return;\n    }\n});\n```\n\n其中可以看出, 我们对 event 的类型进行检查, 来判断是 attach 还是 detach.\n\n### RxRecyclerViewAdapter\n\nRxRecyclerViewAdapter 中提供了对 Adapter 数据集变动的一个观察方法 dataChanges:\n\n```java\nRxRecyclerViewAdapter.dataChanges(mSimpleAdapter).subscribe(simpleAdapter -> {\n    Log.d(\"maxiee\", \"dataChanges\");\n});\n```\n\n上面代码的作用是如果数据发生变动, 就打一个 log.\n\n我们创建一个按钮, 当点击的时候将 Adapter 的一个元素进行替换:\n\n```java\nRxView.clicks(mButtonReplaceItem).subscribe(e -> {\n    mSimpleAdapter.replaceItem(1, \"Maxiee\");\n    mSimpleAdapter.notifyDataSetChanged();\n});\n```\n\n这样, 当我们点击按钮后, 界面的第一个元素文字会更新, 同时也会记录 `dataChanges` log.\n\n### RxRecyclerView 小结\n\n至此, `rxbinding-recyclerview-v7` 包提供的功能我们就全看完了, 一共就这么多.\n\n对于这部分, 我有两个想法:\n\n1.  `rxbinding-recyclerview-v7` 提供的功能太少了, 只绑定了两个回调\n2.  没有对于业务的封装, 我们平时使用往往对 recyclerview 进行二次封装, 方便使用, 对于这一点, 正好可以作为思考题进行练手, 比如思考怎么实现一个底部加载, 下拉刷新等等\n\n## Support v4\n\nRxBindings 提供了一个 `rxbinding-support-v4`, 对 Support v4 进行封装, 主要提供了两种封装:\n\n-   RxViewPager\n-   RxMeuItemCompat\n\n由于使用的方法以及实现的原理都大同小异, 这里只说重点了.\n\n### RxViewPager\n\n#### pageScrollStateChanges\n\n检测 ViewPager 的滑动状态, 这个跟前面的 RecyclerView 的 scrollStateChagnes 有些类似:\n\n```\nRxViewPager.pageScrollStateChanges(mViewPager).subscribe(integer -> {\n    Log.d(\"maxiee\", \"pageScrollStateChanges \" + integer);\n});\n```\n\nLog:\n\n```\n07-25 10:56:42.070 D/maxiee: pageScrollStateChanges 1\n07-25 10:56:42.100 D/maxiee: pageScrollStateChanges 2\n07-25 10:56:42.340 D/maxiee: pageScrollStateChanges 0\n07-25 10:56:46.650 D/maxiee: pageScrollStateChanges 1\n07-25 10:56:46.800 D/maxiee: pageScrollStateChanges 2\n07-25 10:56:47.440 D/maxiee: pageScrollStateChanges 0\n07-25 10:56:47.740 D/maxiee: pageScrollStateChanges 1\n07-25 10:56:48.350 D/maxiee: pageScrollStateChanges 2\n07-25 10:56:48.990 D/maxiee: pageScrollStateChanges 0\n```\n\n其中数值的定义跟前面 RecyclerView 的 scrollStateChagnes 中的定义含义是一致的.\n\n#### pageSelections\n\n监听所选择的页面.\n\n```\nRxViewPager.pageSelections(mViewPager).subscribe(integer -> {\n    Log.d(\"maxiee\", \"pageSelections \" + integer);\n});\n```\n\nLog:\n\n```\n07-25 11:03:26.100 D/maxiee: pageSelections 0\n07-25 11:03:36.350 D/maxiee: pageSelections 1\n07-25 11:03:37.620 D/maxiee: pageSelections 2\n```\n\n#### currentItem\n\n这是一个 Consumer, 接收一个整型, 用来切换 ViewPager 的 Tab 页.\n\n例如, 我使用 3 个按钮, 点击分别切换到某个页面:\n\n```\nRxView.clicks(mBtnTab1).map(o -> 0).subscribe(RxViewPager.currentItem(mViewPager));\nRxView.clicks(mBtnTab2).map(o -> 1).subscribe(RxViewPager.currentItem(mViewPager));\nRxView.clicks(mBtnTab3).map(o -> 2).subscribe(RxViewPager.currentItem(mViewPager));\n```\n\n## Support v4 小节\n\n我们以 ViewPager 为例探索了  `rxbinding-support-v4` 这个包.\n\n从中可以看出, 在掌握了 RxBinding 的原理之后, 对于不同控件的封装的过程都是一样的.\n\n有一点还需要强调, 前面对视图套上 RxBinding 的封装后, RxBinding 类的实例就对这个视图有了强引用, 这会导致内存泄漏问题.\n\n解决的方法是使用第二篇中, 把每次订阅后得到的 Disposable 存放到 CompositeDisposable 中, 等到生命周期结束的时候统一进行清空解绑.\n\n## 总结\n\n至此, 我们通过两篇博客完成了对 RxBinding 的学习.\n\n我们学习了对常见控件封装的使用, 一些常见的应用场景, 以及 RxBinding 的内部实现原理.\n\nRxBinding 还有一些比较有意思的包:\n\n-   `rxbinding-appcompat-v7`\n-   `rxbinding-design`\n\n里面提供的控件封装都非常实用.\n\n这里就不在罗列它们的使用了, 用法都是一样的.\n\n到目前为止, 我们对 RxJava 操作 UI 已经具备了一定的基础了, 从下一篇开始, 我们将探索新的主题."},"path":"post/Rxjava5md"}
