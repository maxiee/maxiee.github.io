{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（二）：JS Bundle 的加载原理（Android）","desc":"React Native 代码阅读系列第二篇，JS Bundle 在 React Native 中是如何加载运行的呢？在本文中，我们通过 JSBundleLoader 类作为切入点，对这个过程一探究竟。","type":"md","link":"ReactNativeCode2md","create":"2019-01-31","filename":"ReactNativeCode2.md"},"content":"## 介绍\n\nJS Bundle 在 React Native 中是如何加载运行的呢？在本文中，我们通过 JSBundleLoader 类作为切入点，对这个过程一探究竟。\n\nJSBundleLoader 类的作用是：它存储 JS 包信息，并允许通过 ReactBridge 加载包。\n\n这个类本身很简单，是一个抽象类：\n\n```java\npublic abstract class JSBundleLoader {\n\n    public abstract String loadScript(CatalystInstanceImpl instance);\n\n}\n```\n\n其中：\n\n-   它的内部很简单，只有一个方法 loadScript\n-   接收参数 CatalystInstanceImpl，CatalystInstanceImpl 提供了各种加载能力供 JSBundleLoader 调用\n\n## Loader 的种类\n\n在 JSBundleLoader 中通过静态方法的形式对外暴露了几种 Loader 的创建方法，有如下几类：\n\n-   AssetLoader：\n    -   JS Bundle 放在 APP 的 assets 目录下\n    -   JS Bundle 会使用 Native 代码（C/C++）进行加载，之所以不在 Java 加载，因为 JS Bundle 是很大的字符串，这样可以在 Java-Native 之相互传递时的内存开销\n-   FileLoader\n    -   JS Bundle 放在文件系统当中\n-   NetworkLoader\n    -   向服务器请求 Bundle\n    -   有两种请求方式：请求全量包、请求差分包\n\n## AssetLoader\n\n### 介绍\n\n在本节中，我们主要来看 AssetLoader。\n\n在上一节，ReactInstanceManagerBuilder 中的 build 一步，会创建 AssetLoader：\n\n```java\npublic ReactInstanceManager build() {\n    ...\n    return new ReactInstanceManager(\n        mApplication,\n        mCurrentActivity,\n        mDefaultHardwareBackBtnHandler,\n        mJavaScriptExecutorFactory == null\n            ? new JSCJavaScriptExecutorFactory(appName, deviceName)\n            : mJavaScriptExecutorFactory,\n        (mJSBundleLoader == null && mJSBundleAssetUrl != null)\n            ? JSBundleLoader.createAssetLoader(\n                mApplication, mJSBundleAssetUrl, false /*Asynchronous*/)\n            : mJSBundleLoader,\n        mJSMainModulePath,\n```\n\n其中，createAssetLoader 的签名为：\n\n```java\npublic static JSBundleLoader createAssetLoader(\n    final Context context,\n    final String assetUrl,\n    final boolean loadSynchronously) {\n```\n\n其中：\n\n-   context：Android Context\n-   assetUrl：JS 包在 Assets 目录下的地址\n-   loadSynchronously：同步加载还是异步加载，在这里是异步加载\n\n### createAssetLoader\n\n我们来看 createAssetLoader 的内部实现：\n\n```java\npublic static JSBundleLoader createAssetLoader(\n    final Context context,\n    final String assetUrl,\n    final boolean loadSynchronously) {\n    return new JSBundleLoader() {\n        @Override\n        public String loadScript(CatalystInstanceImpl instance) {\n            instance.loadScriptFromAssets(context.getAssets(), assetUrl, loadSynchronously);\n            return assetUrl;\n        }\n    };\n}\n```\n\n其中：\n\n-   返回了一个匿名内部类，并实现了 loadScript 方法\n-   loadScript 内部，则是调用 CatalystInstanceImpl 提供的 loadScriptFromAssets 能力\n-   也就是说，loader 本身没干事，真正干事的是 CatalystInstanceImpl\n\n### CatalystInstanceImpl.loadScriptFromAssets\n\n我们进入 CatalystInstanceImpl.loadScriptFromAssets，实际加载的逻辑都在这里面。这个方法的定义如下：\n\n```java\n/* package */ void loadScriptFromAssets(AssetManager assetManager, String assetURL, boolean loadSynchronously) {\n    mSourceURL = assetURL;\n    jniLoadScriptFromAssets(assetManager, assetURL, loadSynchronously);\n}\n```\n\n由此可以看出，它首先把 URL 保存下来，之后实际加载是调用 JNI 方法，进入 Native 层来实现的。\n\n我们进入到 Native 层方法，位于 ReactAndroid/src/main/jni/react/jni/CatalystInstanceImpl.cpp。首先看方法签名：\n\n```c++\nvoid CatalystInstanceImpl::jniLoadScriptFromAssets(\n    jni::alias_ref<JAssetManager::javaobject> assetManager,\n    const std::string& assetURL,\n    bool loadSynchronously) {\n```\n\n其中：\n\n-   `jni::alias_ref<JAssetManager::javaobject>` 是 fbjni 提供的一种 Java 类映射方法\n\n首先我们通过下面代码，拿到 AssetManager 在 C++ 中的实例：\n\n```c++\nauto manager = extractAssetManager(assetManager);\n```\n\n通过下面方法读取 Bundle 的内容：\n\n```c++\nauto script = loadScriptFromAssets(manager, sourceURL);\n```\n\n其中，loadScriptFromAssets 方法并不复杂，我们略过。\n\n现在我们读取的包还是字符串，下面要对它进行解析：\n\n```c++\ninstance_->loadScriptFromString(std::move(script), sourceURL, loadSynchronously);\n```\n\n其中：\n\n-   `instance_` 是 Native 层 CatalystInstanceImpl 类的成员，类型为 Instance（位于 ReactCommon/cxxreact/Instance.h）。\n\n### Instance.loadScriptFromString\n\n这个方法的签名如下：\n\n```c++\nvoid Instance::loadScriptFromString(std::unique_ptr<const JSBigString> string,\n                                    std::string sourceURL,\n                                    bool loadSynchronously) {\n```\n\n其中：\n\n-   string 是我们的 Bundle 的字符串\n-   loadSynchronously 加载方式这里是同步加载\n\n这会调用:\n\n```c++\nloadApplicationSync(nullptr, std::move(string), std::move(sourceURL));\n```\n\n我们进入 loadApplicationSync：\n\n```c++\nnativeToJsBridge_->loadApplicationSync(std::move(bundleRegistry), std::move(string),\n                                       std::move(sourceURL));\n```\n\n其中：\n\n-   第一个参数我们实际传入的是 nullptr\n-   `nativeToJsBridge_` 是 Instance 类的成员，其类型为 NativeToJsBridge。\n-   NativeToJsBridge 类的作用是处理 Native 调 JS。\n\n### NativeToJsBridge.loadApplicationSync\n\n方法签名为：\n\n```c++\nvoid NativeToJsBridge::loadApplicationSync(\n    std::unique_ptr<RAMBundleRegistry> bundleRegistry,\n    std::unique_ptr<const JSBigString> startupScript,\n    std::string startupScriptSourceURL) {\n```\n\n其中：\n\n-   bundleRegistry 实际传入的是 nullptr\n-   startupScript 是我们 Bundle 的字符串\n\n方法内部调用了：\n\n```c++\nm_executor->loadApplicationScript(std::move(startupScript), std::move(startupScriptSourceURL));\n```\n\n其中：\n\n-   `m_executor` 是 NativeToJsBridge 类的成员，类型为 JSExecutor\n-   JSExecutor 的作用是在 JS 环境中执行\n\n### JSExecutor\n\nNative 层的 JSExecutor 位于 ReactCommon/cxxreact/JSExecutor.h，需要注意的是它是一个抽象类。\n\n它的实现类是：JSCExecutor：位于 ReactCommon/cxxreact/JSCExecutor.h\n\n这里设计 JSExecutor 这样一个隔离层的意思是 JS 引擎可隔离，React Native 选用的 JS 引擎是 JavaScriptCore，但是通过隔离层，我们完全可以换用其他的引擎。 \n\n### JSCExecutor.loadApplicationScript\n\n这里我们来看 JSCExecutor 的 loadApplicationScript 方法，方法签名：\n\n```c++\nvoid JSCExecutor::loadApplicationScript(\n    std::unique_ptr<const JSBigString> script,\n    std::string sourceURL) {\n```\n\n其中两个参数：包的内容以及包的路径。\n\n核心的方法是这一句：\n\n```c++\nevaluateScript(m_context, jsScript, jsSourceURL);\n```\n\n这个方法的定义位于 ReactCommon/jschelpers/JSCHelpers.cpp：\n\n```c++\nJSValueRef evaluateScript(JSContextRef context, JSStringRef script, JSStringRef sourceURL) {\n  JSValueRef exn, result;\n  result = JSC_JSEvaluateScript(context, script, NULL, sourceURL, 0, &exn);\n  if (result == nullptr) {\n    throw JSException(context, exn, sourceURL);\n  }\n  return result;\n}\n```\n\n到这里，我们已经进入了 JavaScriptCore 的世界中了。\n\n### `JSC_JSEvaluateScript_`\n\n下面我们进入 JavaScriptCore 的源码。`JSC_JSEvaluateScript_` 定义在 JavaScriptCore.h 中，它是一个宏：\n\n```c\n#define JSC_JSEvaluateScript(...) __jsc_wrapper(JSEvaluateScript, __VA_ARGS__)\n```\n\n`__jsc_wrapper` 也是一个宏：\n\n```c\n#define __jsc_wrapper(method, ctx, ...) method(ctx, ## __VA_ARGS__)\n```\n\n最终来到了 JSBase.h 中的：\n\n```c\nJS_EXPORT JSValueRef JSEvaluateScript(\n                JSContextRef ctx,          // JavaScript Runtime Context\n                JSStringRef script,        // JS Bundle\n                JSObjectRef thisObject,    // 用作 this 的对象，这里是 NULL\n                JSStringRef sourceURL,     // 路径，也就是我们的 bundle path\n                int startingLineNumber,    // 如果报错了，抛出异常的行号\n                JSValueRef* exception);    // 用于抛异常的指针\n```\n\n这个方法的作用就是执行 JS 脚本。\n\n### 小结\n\n至此，我们就一路从 Java 层的 BundleLoader，到了 Native 层加载 Bundle 代码，再从 React Native 的代码进入 JavaScriptCore 的代码。完整地走了一趟 JS Bundle 从加载到执行的全过程。\n\n## 外部调用\n\n### 介绍\n\n前面我们对 JSBundleLoader 内部完成了一探究竟。在本节中，我们把 JSBundleLoader 当做一个黑盒，看看外面是如何使用它的。\n\n还记得 CataLystInstanceBuilder 创建了 AssetLoader 的实例吗？\n\nJSBundleLoader 是作为 CatalystInstance 的成员进行持有的。我们回到 Java 世界中的 CatalystInstanceImpl.java。\n\nJSBundleLoader 在其中作为一个成员：\n\n```java\nprivate final JSBundleLoader mJSBundleLoader;\n```\n\n它在 CatalystInstanceImpl 中是如何使用的呢？\n\n位于 runJSBundle 方法中：\n\n```java\n@Override\npublic void runJSBundle() {\n    mJSBundleLoader.loadScript(CatalystInstanceImpl.this);\n    ...\n}\n```\n\n下面我们由内而外地去梳理。\n\n### CatalystInstanceImpl.runJSBundle\n\n这个方法在哪里被调用了呢？\n\n我们找到了在 ReactInstanceManager.createReactContext 中。这与我们系列中的第一篇已经呼应上了。\n\n### ReactInstanceManager.createReactContext\n\n这个方法在哪里被调用了呢？\n\n答案是在 ReactInstanceManager.runCreateReactContextOnNewThread 中。\n\n我们再往上跟：\n\n-   ReactInstanceManager.recreateReactContextInBackground\n    -   ReactInstanceManager.recreateReactContextInBackgroundFromBundleLoader\n        -   ReactInstanceManager.recreateReactContextInBackgroundInner\n            -   ReactInstanceManager.createReactContextInBackground\n                -   ReactRootView.startReactApplication\n                    -   MainActivity: mReactRootView.startReactApplication\n\n这样，我们又反向地把第一篇中的路径反走了一遍，一正一反，对整个过程有了更深的认识了。\n\n## 结论\n\n在本文中，我们从 JSBundleLoader 入手，将 JS Bundle 的加载、执行流程完整地分析了一遍。\n\n"},"path":"post/ReactNativeCode2md"}
