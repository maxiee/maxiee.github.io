{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"Maxiee 的 RxJava 学习指南 (4) - RxBinding","desc":"从这一篇我们开始对 RxBinding 库的学习, 主要学习它对按钮的封装, 以及它内部的实现原理.","type":"md","link":"Rxjava4md","create":"2017-06-21","filename":"Rxjava4.md"},"content":"## 介绍\n\n从这一篇我们开始对 [RxBinding 库](https://github.com/JakeWharton/RxBinding)的学习, 主要学习它对按钮的封装, 以及它内部的实现原理.\n\n对于[RxBinding 库](https://github.com/JakeWharton/RxBinding)的使用, 网上已经有许多优秀的教程了. 我简单地梳理了一下:\n\n| 文章                                       | 介绍                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| [使用RxBinding响应控件的异步事件](http://www.jianshu.com/p/c2c7c46e6b97) | 以一个 Demo 示例来讲解, RxToolbar, RxSnackbar    |\n| [RxBinding 学习笔记](http://dongchuan.github.io/android/2016/08/21/Android-RxBinding.html) | 基本用法, 点击, ListView 点击事件, 结合使用操作符         |\n| [RxBinding(JakeWharton/RxBinding)](https://yongjhih.gitbooks.io/feed/rxbinding.html) | 实例: 验证过滤, 流量控制                           |\n| [RxJava RxBinding基础](http://lovehaodong.cn/2017/03/11/RxJava%20RxBinding/) | 按钮点击, 按钮防抖, EditText 文本改变, CheckBox, RecyclerView |\n| [一些RxBinding使用场景](http://blog.csdn.net/qq_17766199/article/details/54646011) | 按钮防抖, 多次监听, 倒计时, 表单验证                    |\n| [RxJava 和 RxAndroid 四（RxBinding的使用）](http://www.cnblogs.com/zhaoyanjun/p/5535651.html) | 按钮防抖,  按钮的长按时间监听, ListView, CheckBox     |\n\n## 实例项目\n\n我在 GitHub 上建立了一个项目 [MaxieeRxLearning](https://github.com/maxiee/MaxieeRxLearning) 作为对学习的总结.\n\n本文中我会用  [MaxieeRxLearning](https://github.com/maxiee/MaxieeRxLearning) 中的代码来进行讲解, 因此建议先将这个项目 Clone 下来参照着学习.\n\nRxBinding 按钮的演示代码位于 `ButtonFragment`, 截图如下:\n\n![device-2017-06-20-192143](http://7xohx8.com1.z0.glb.clouddn.com/device-2017-06-20-192143.png)\n\n一共有 4 种常用情况, 下面依次说明.\n\n## 普通点击\n\n代码:\n\n```java\nRxView.clicks(mNormalClickButton).subscribe(\n        Object -> mNormalClickTextView.setText(\n                \"Clicked at \" + System.currentTimeMillis()));\n```\n\n每次点击按钮, 订阅者就会被触发, 执行操作. 在这里所执行的操作是更新 TextView.\n\n## 长点击\n\n代码:\n\n```java\nRxView.longClicks(mLongClickButton).subscribe(\n        object -> mLongClickTextView.setText(\n                \"Long click at \" + System.currentTimeMillis()));\n```\n\n只有长点击才会响应, 普通点击不会触发.\n\n## 防抖点击\n\n代码:\n\n```java\nRxView.clicks(mThrottleClickButton)\n        .throttleFirst(5, TimeUnit.SECONDS)\n        .subscribe(\n                object -> mThrottleTextView.setText(\n                        \"Clicked at \" + System.currentTimeMillis()));\n```\n\n上面代码中防抖点击的功能时这样的:\n\n- 第一次的点击能够触发观察者\n- 在这之后的 5 秒内点击都不会触发\n- 过了 5 秒后复位, 再次点击回到第一步情况\n\n注意, 防抖的功能是将 RxBinding 的 `RxView.clicks()` 和 RxJava 的 throttleFirst 操作符组合起来使用的. throttleFirst 的文档在[这里](http://reactivex.io/documentation/operators/sample.html).\n\n## Enable 控制\n\n这个 Demo 是有一个 CheckBox 它能控制 Button 的 Enable 属性, CheckBox 勾选 Button 的 enable 为 true, 按钮可点击, 反之亦然. 代码:\n\n```java\nRxCompoundButton.checkedChanges(mCheckEnable).subscribe(\n        RxView.enabled(mCheckButton));\n\nRxView.clicks(mCheckButton).subscribe(\n        object -> mCheckTextView.setText(\n                \"Clicked at \" + System.currentTimeMillis()));\n```\n\n其中:\n\n- `RxCompoundButton.checkedChanges` 观察的是 CheckBox 的勾选状态, 在观察者中调用 `RxView.enabled` 改变按钮的 Enable 属性.\n- 这里细心的同学会发现, `enabled` 传入参数呢? `enabled` 类型是 `Consumer<? super Boolean>`, `checkedChanges` 类型是 `InitialValueObservable<Boolean>`, 都被封装了.\n- 按钮点击的代码跟普通点击是一样的\n\n这个 Demo 一般应用于点击 \"已阅读协议\" 然后才允许用户注册的页面.\n\n## RxView.clicks 实现\n\n前面介绍了很多实用的例子, 它们的底层是怎么实现的呢? 我们以 `RxView.clicks` 为例来看一下.\n\n给按钮设置回调的方法是:\n\n```java\nview.setOnClickListener(OnClickListener listener);\n```\n\n我们要做的是, 封装一个 Observable, 当点击回调触发时, 向 observer 发一个 onNext, 那怎么实现呢?\n\n首先我们创建一个 Observable:\n\n```java\nfinal class MaxieeViewClickObservable extends Observable<Object> {\n    private final View mView;\n\n    ViewClickObservable(View view) {\n        mView = view;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super Object> observer) { ... }\n}\n```\n\n其中, `subscribeActual` 是干什么的呢? 它是 RxJava 内部的一个核心要点.\n\n我们知道, 被观察者被观察者订阅, 他俩就建立起关系来了, 当被观察者发出数据就能触发观察者.\n\n现在的问题是, 这个触发是怎么进行的? 就是通过 Observable 的 `subscribeActual` 实现的.\n\n我们补全上面空着的 `subscribeActual`:\n\n```java\nprivate static class MaxieeViewClickObservable extends Observable<Object> {\n    private View mView;\n\n    MaxieeViewClickObservable(View view) {\n        mView = view;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super Object> observer) {\n        mView.setOnClickListener(v -> observer.onNext(null));\n    }\n}\n```\n\n其中, 建立关系的方式很简单, 创建一个点击回调绑定给 view, 回调的内容是调用  observer 的 onNext.\n\nRxJava 中被观察者和观察者的触发就是通过这种机制建立起来的.\n\nRxBinding 提供了一个工具方法, 也就是 `RxView.clicks()` 做了一个封装, 它的实现是这样:\n\n```java\npublic static Observable<Object> clicks(View view) {\n    return new MaxieeViewClickObservable(view);\n}\n```\n\n这样我们的 clicks 跟 `RxView.clicks()` 就能一样使用了:\n\n```java\nclicks(mHomeBrewButton).subscribe(\n        object -> mHomeBrewTextView.setText(\n                \"Clicked at \" + System.currentTimeMillis()));\n```\n\n上面这个代码展示了 RxView.clicks 的最核心的实现原理. \n\n在理解了核心原理之后, 这段代码还有不完善的地方, 许多地方还有问题, 我们将在下一节中来完善它们.\n\n## RxView.clicks 进阶\n\n上面我们实现的代码, 第一个问题是在解绑时会有问题.\n\n我们用以下代码来解绑:\n\n```java\nDisposable d = clicks(mHomeBrewButton).subscribe(\n        object -> mHomeBrewTextView.setText(\n                \"Clicked at \" + System.currentTimeMillis()));\n\nd.dispose();\n```\n\n这样再次运行, 点击按钮确实不会触发 TextView 变化了. 表面上没问题, 实际上有问题:\n\ndispose 之后, button 的 OnClickListener 实现中仍然持有者 observer 对象. 这回造成内存泄漏.\n\n怎么解决呢? 在  `subscribeActual` 中调用 observer 的 onSubscribe 方法, 传入一个 Disposable, 在 observer dispose 的时候会调用这个 Disposable 的 onDispose, 在里面将点击回调清空.\n\n其中 onSubscribe 是 RxJava 中观察者 dispose 取消订阅时, 被观察者进行资源释放的机制.\n\n写成代码就是:\n\n```java\n@Override\nprotected void subscribeActual(Observer<? super Object> observer) {\n    mView.setOnClickListener(v -> observer.onNext(null));\n\n    observer.onSubscribe(new Disposable() {\n        private boolean mDisposed = false;\n\n        @Override\n        public void dispose() {\n            Log.d(\"maxiee\", \"clear the click listener of button\");\n            mView.setOnClickListener(null);\n            mDisposed = true;\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return mDisposed;\n        }\n    });\n}\n```\n\n这样, 当观察者取消订阅时, 按钮的点击回调也就清空了, 也就是释放了资源.\n\n有一点要注意的是, 我在上面的实现跟 RxBinding 的实现有所不同, 但是原理是一样的, 上面这样写比较易于理解.\n\nRxBinding 的实现如下:\n\n```java\nfinal class ViewClickObservable extends Observable<Object> {\n  private final View view;\n\n  ViewClickObservable(View view) {\n    this.view = view;\n  }\n\n  @Override protected void subscribeActual(Observer<? super Object> observer) {\n    if (!checkMainThread(observer)) {\n      return;\n    }\n    Listener listener = new Listener(view, observer);\n    observer.onSubscribe(listener);\n    view.setOnClickListener(listener);\n  }\n\n  static final class Listener extends MainThreadDisposable implements OnClickListener {\n    private final View view;\n    private final Observer<? super Object> observer;\n\n    Listener(View view, Observer<? super Object> observer) {\n      this.view = view;\n      this.observer = observer;\n    }\n\n    @Override public void onClick(View v) {\n      if (!isDisposed()) {\n        observer.onNext(Notification.INSTANCE);\n      }\n    }\n\n    @Override protected void onDispose() {\n      view.setOnClickListener(null);\n    }\n  }\n}\n```\n\n其中:\n\n-   OnClickListener 跟 MainThreadDisposable 合并成一个 Listener\n-   MainThreadDisposable 是 RxAndroid 提供的一种 Disposable, 等我们学习 RxAndroid 时再回头看\n\n\n## 总结\n\n在本篇中, 我们首先学习了 RxBinding 按钮的常用使用场景. 在此基础之上, 我们深入 RxBinding 底层, 学习了它的实现原理. 在学习原理的过程中, 我们学习了 RxJava2 的绑定与解绑的底层实现机制.\n\n原理学会之后, 会发现各种绑定都很简单, 因此在下一篇中我会加快一点速度, 罗列 RxBinding 控件的使用场景."},"path":"post/Rxjava4md"}
