{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（十四）：UIManagerModule 与 ReactNativeRenderer","desc":"UIManagerModule 是 React Native 中视图展示的核心模块，通过挖掘 UIManagerModule，又发现了 JS 侧的 ReactNativeRenderer，最终将整个渲染流程串联起来。","type":"md","link":"ReactNativeCode14md","create":"2019-04-09","filename":"ReactNativeCode14.md"},"content":"## 前言\n\nUIManagerModule 是 React Native 中视图展示的核心模块，通过挖掘 UIManagerModule，又发现了 JS 侧的 ReactNativeRenderer，最终将整个渲染流程串联起来。\n\n## 创建\n\nUIManagerModule 是如何创建的呢？为了回答这个问题，有许多相关的概念需要介绍。\n\n我们在写 Native Modules 是都需要创建一个 Package。React Native 内部也是使用 Package 机制来构成的。在 Package 内部包含有 Native Modules 和 ViewManagers。\n\n在这些内置 Package 中，最重要的一个是 CoreModulesPackage。它为 React Native 提供了核心支撑能力。\n\nCoreModulesPackage 中一个非常重要的模块就是 UIManagerModule，\n\nUIManagerModule 的创建就是在 CoreModulesPackage 的 createUIManager 方法中。\n\n## 谁会获取 UIManagerModule\n\n在上一节中我们知道了 UIManagerModule 是 CoreModulesPackage 中的一个 Module。\n\n因此接下来的问题是，在 React Native 中，谁会获取 UIManagerModule 呢？\n\n首先 UIManagerModule 中一个常量 `NAME`，作为这个模块的标识：\n\n```java\npublic static final String NAME = \"UIManager\";\n```\n\n我们可以通过这个线索入手。找到了这么几个地方：\n\n- Libraries/Renderer/oss/ReactFabric-dev.js\n- Libraries/Renderer/oss/ReactFabric-prod.js\n- Libraries/Renderer/oss/ReactNativeRenderer-dev.js\n- Libraries/Renderer/oss/ReactNativeRenderer-prod.js\n- com/facebook/react/bridge/NativeModuleRegistry.java\n\n其中：\n\n- 大多都是 JS 侧的引用，只有一个是 Java 侧的引用\n- 同时可以看出，这个部分可能与 Fabric 重构有关，这引起了我的兴趣\n\n## ReactFabric\n\n在上面的调用放中，最引起我注意的是 ReactFabric。\n\n在本节中我们来看看它，首先它不是最原始的代码，而是经过了一次 build，这个文件总共接近 2w 行。\n\n我们直接看最底部：\n\n```js\nvar fabric = ReactFabric$3.default || ReactFabric$3;\n\nmodule.exports = fabric;\n\n  })();\n}\n```\n\n它对外导出了一个 fabric 对象，看起来跟 Fabric 重构有很大的关系。\n\n第一个需要确认的是：ReactFabric 到底有没有执行呢？\n\n最简单的方法是给它改改，我将上面代码加了一行 log：\n\n```js\nvar fabric = ReactFabric$3.default || ReactFabric$3;\n\nconsole.log(\"maxiee -> run here!\")\n\nmodule.exports = fabric;\n\n  })();\n}\n```\n\n## ReactNativeRenderer-dev.js\n\n经过一番疯狂打 log 试探，我发现 ReactFabric 并没有走到，而是走到了 ReactNativeRenderer-dev.js。\n\n我猜测 ReactNativeRenderer-dev.js 这个还是 Fabric 重构之前的，ReactFabric 还没有生效。\n\nReactFabric 我们就先不管它了，来看 ReactNativeRenderer。\n\n### UIManager 的 JS 映射\n\nUIManager 既然是一个 Native Module，他应该有一个在 JS 侧的映射类。\n\n在 ReactNativeRenderer 中导入 UIManager 通过下面方法：\n\n```js\nvar UIManager = require(\"UIManager\");\n```\n\n这个映射类在哪里呢？它位于 Libraries/ReactNative/UIManager.js。\n\n我们先不细看它内部的实现，只知道它在 JS 侧提供了 UIManager 的映射即可。\n\n让我们回到 ReactNativeRenderer。\n\n### ReactNativeRenderer 跟 React 的关系\n\n在这个文件的提交记录中，我发现大多都是：\n\n```\nReact sync for revisions ...\n```\n\n莫非这个文件里包含了 React？看到其中一行就真相大白了：\n\n```js\nvar React = require(\"react\");\n```\n\nReactNativeRenderer 引用了 React，估计是在底层进行了桥接功能。\n\n去网上搜索了一下，找到一篇非常好的文章：\n\n- [「ReactNative」View创建过程浅析](https://juejin.im/post/5bfbaaf1f265da615a417f69)\n- [「ReactNative」View创建过程浅析](https://tech.meicai.cn/detail/66%EF%BC%8C)\n\n粗略地阅读了一下，可以知道：\n\n- 这个文件与 React 有莫大的关系\n- React Native 中 Component 的 render 方法都是通过这个文件中的方法来创建的\n- ReactNativeRenderer 中的方法会进一步调用 UIManager 来进行 Native View 的创建\n- 我的前一篇文章覆盖了《「ReactNative」View创建过程浅析》后面的 Native 部分，本文相当于它的中间一小部分\n- 我会在后面的文章中逐渐吃透《「ReactNative」View创建过程浅析》，梳理出整个全流程\n\n### ReactNativeRenderer.createInstance\n\n在这里我们先从简单的来，ReactNativeRenderer 引用了 UIManager，它都是怎么用的呢？\n\n在 ReactNativeRenderer 里找了一圈，我找到一个吸引我的方法 —— createInstance。\n\n它的方法签名如下：\n\n```js\nfunction createInstance(\n  type,\n  props,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n```\n\n省略一些中间代码，我们直取核心。调用 UIManager.createView 创建视图：\n\n```js\nUIManager.createView(\n  tag, // reactTag\n  viewConfig.uiViewClassName, // viewName\n  rootContainerInstance, // rootTag\n  updatePayload // props\n);\n```\n\n这一步会最终调用到 Java 层 com.facebook.react.uimanager.UIManagerModule#createView。\n\n在这里跟我们上一篇[《React Native 代码阅读（十三）：View 是如何创建的》](https://maxiee.github.io/post/ReactNativeCode13.md/) 完美地串起来了。\n\n在上一篇中，我们是通过 spy bridge 发现调用 com.facebook.react.uimanager.UIManagerModule#createView，而在这里发现是引用 Native Module 发现这个调用的，这说明什么呢？\n\n这说明 Native Module 内部的机制是通过发送 bridge message 来告知 Java 层进行方法调用的。\n\n这又能与更早的系列文章串起来，由点及线，说明我们要开始掌握了。\n\n之后创建了一个 component：\n\n```js\nvar component = new ReactNativeFiberHostComponent(tag, viewConfig);\n```\n\n最终返回组件：\n\n```js\nreturn component;\n```\n\n### 哪里调用了 createInstance？\n\n让我们再进一步来看，哪里调用了 createInstance？\n\n在 completeWork 方法中调用了它。\n\n谁调用了 completeWork 呢? completeUnitOfWork\n\n谁调用了 completeUnitOfWork 呢？renderRoot 和 performUnitOfWork\n\n谁调用了 performUnitOfWork 呢？workLoop\n\n谁调用了 workLoop 呢？renderRoot 和 replayUnitOfWork\n\n结合《「ReactNative」View创建过程浅析》我们知道 Component 的 render 方法最终会调到 renderRoot\n\n因此通过这番跟踪，摸清了 ReactNativeRenderer 的一条主线\n\n### ReactNativeRenderer 如何使用 React？\n\n在上文中我们看到了 ReactNativeRenderer 引用了 React，那它是如何使用它的呢？\n\nReactNativeRenderer 虽然有两万行之多，但是实际上没几处直接使用 React 的地方，但是这一行吸引了我的注意：\n\n```js\nvar ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n```\n\n其中：\n\n- 这个命名方式笑死我了\n- 看来是 React 开了一个口子啊\n- 我猜 React Native 就是通过它接管了 DOM 节点的渲染能力\n\n`__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED` 这个变量很重要，通过它作为关键字能够搜到很多关于 React 代码阅读的资料。\n\n## UIManagerModule 中的方法\n\n有了前面这些 JS 侧的积累，下面我们再回到 Java 侧的 UIManagerModule 中，看看都提供了哪些 React Method：\n\n- getConstantsForViewManager\n- getDefaultEventTypes\n- removeRootView\n- createView\n- updateView\n- manageChildren\n- setChildren\n- replaceExistingNonRootView\n- removeSubviewsFromContainerWithID\n- measure\n- measureInWindow\n- measureLayout\n- measureLayoutRelativeToParent\n- findSubviewIn\n- viewIsDescendantOf\n- setJSResponder\n- clearJSResponder\n- dispatchViewManagerCommand\n- playTouchSound\n- showPopupMenu\n- dismissPopupMenu\n- configureNextLayoutAnimation\n- sendAccessibilityEvent\n\nUIManagerModule 向 JS 侧提供了这些方法，供 React Native Renderer 调用。\n\n通过这里，我也明白了为啥 React 要拆包拆出来 React 和 React DOM 两个包。\n\n## 总结\n\n在本文中，通过学习 ReactNativeRenderer 这个文件，终于将 React Native 的渲染流程给完整地串起来了。\n\n经过这十四篇文章，我对 React Native 的整体框架由模糊变清晰了一些。在后续的文章中，我会让这个框架变得更加显化。\n\n## 附录\n\n以下是我在学习代码过程中总结，可能与主题相关不大，但是也有价值。\n\n舍不得删，列举在下方：\n\n### ReactPackage\n\nReactPackage 是一个接口。它有详细的注释：\n\n它是向 catalyst 框架提供额外功能的主要接口，通过以下几种方式：\n\n1. 注册新的 Native 模块\n2. 注册新的 JS 模块，可以在 Native 模块或者其他代码中访问\n  - 依赖 JS 模块不会自动将其打包进 JS Bundle，因此还需要在 JS 侧有对应的代码来导入 JS 模块的实现到 Bundle 中\n3. 注册自定义 Native View（View Managers）和自定义事件类型\n4. 注册原生资源（比如图片）暴露给 JS\n\n它包含两个接口方法：\n\n- createNativeModules：创建 Native Modules\n- createViewManagers：创建 ViewManagers\n\n这个跟我们平时创建 NativeModule 的时候是一样的。\n\n### LazyReactPackage 与 TurboReactPackage\n\n在学习代码的时候，我看到了两个类：LazyReactPackage 与 TurboReactPackage，他俩什么关系呢？\n\n- com.facebook.react.LazyReactPackage\n- com.facebook.react.TurboReactPackage\n\nTurboReactPackage 是在 Fabric 重构中，基于 TurboModules 的新 ReactPackage，用于替换 LazyReactPackage。这个替换在最新的 React Native 代码中已经完成了，在实际运行时走的是 TurboReactPackage。\n\n需要注意的是，他俩都实现了 ReactPackage。\n\n\n\n\n"},"path":"post/ReactNativeCode14md"}
