{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"Android APP 集成 JavaScriptCore 执行 JavaScript","desc":"在之前的文章中我们编译了供 Android 平台使用的 JavaScriptCore。在本文中，我们的目标是创建一个 Android 工程，导入编译的 JavaScriptCore，并进行 JavaScript 脚本解析。","type":"md","link":"JavaScriptCoreAndroidRunmd","create":"2018-12-21","filename":"JavaScriptCoreAndroidRun.md"},"content":"## 介绍\n\n在之前的文章中我们编译了供 Android 平台使用的 JavaScriptCore。在本文中，我们的目标是创建一个 Android 工程，导入编译的 JavaScriptCore，并进行 JavaScript 脚本解析。\n\n主要有以下步骤：\n\n1.  将 JavaScriptCore 编译为 Android 库（已经完成，参见之前文章）\n2.  在 Android 项目中链接上 JavaScriptCore 库\n3.  调用库执行脚本\n\n在本文中，我们直接从第二步开始。\n\n## 创建新项目\n\n首先，我们在 Android Studio 中创建一个新项目，需要注意的是，要勾选 ****Include C++ support**** 。\n\n项目创建好后，打开项目，C++ 代码都位于：native-lib.cpp 中。\n\n## 导入 JavaScriptCore 库\n\n在 app/src/main 下创建目录 jniLibs，并将所有 so 文件拷贝到该目录下：\n\n```\n.\n├── AndroidManifest.xml\n├── cpp\n│   └── native-lib.cpp\n├── java\n│   └── com\n│       └── maxiee\n│           └── jsclearning1\n│               └── MainActivity.java\n├── jniLibs\n│   ├── arm64-v8a\n│   │   ├── libc++_shared.so\n│   │   └── libjsc.so\n│   ├── armeabi-v7a\n│   │   ├── libc++_shared.so\n│   │   └── libjsc.so\n│   ├── x86\n│   │   ├── libc++_shared.so\n│   │   └── libjsc.so\n│   └── x86_64\n│       ├── libc++_shared.so\n│       └── libjsc.so\n```\n\n导入了 so 库之后，我们还需要导入头文件。需要修改 CMakeLsits.txt，添加以下代码：\n\n```\ninclude_directories(../../path/to/your/header/files)\n```\n\n这里遇到一点问题，我用 jsc-android-buildscripts 编译出来的 dist 目录下，头文件被打平到一个目录下了，而 Header 文件中还是使用 JavaScriptCore 嵌套目录。我的解决方法是修改头文件，修复扁平化引用。\n\n## 问题 ninja error missing and no known rule to make it\n\n看起来是 native-lib 依赖了 jsc，但是在具体连接的时候出现了问题。\n\n通过这篇文章：[Android Studio cmake和jni的一些坑](https://blog.csdn.net/fenjiehuang/article/details/61619817) 找到了原因，是路径的问题。\n\n修改 CMakeLists.txt 为：\n\n```\n# For more information about using CMake with Android Studio, read the\n# documentation: https://d.android.com/studio/projects/add-native-code.html\n\n# Sets the minimum version of CMake required to build the native library.\n\ncmake_minimum_required(VERSION 3.4.1)\n\ninclude_directories(/Users/maxiee/Code/Android/native-js-android/nativejs/src/main/jni/include)\n\nset(CURRENT_DIR ${CMAKE_SOURCE_DIR})\nmessage(\"CURRENT_DIR:\" ${CMAKE_SOURCE_DIR})\n\nadd_library(jsc SHARED IMPORTED)\nset_target_properties( # Specifies the target library.\n                        jsc PROPERTIES\n                        IMPORTED_LOCATION \"${CURRENT_DIR}/src/main/jniLibs/${ANDROID_ABI}/libjsc.so\")\n\nadd_library( # Sets the name of the library.\n                native-lib\n\n                # Sets the library as a shared library.\n                SHARED\n\n                # Provides a relative path to your source file(s).\n                src/main/cpp/native-lib.cpp )\n\nfind_library( # Sets the name of the path variable.\n                log-lib\n\n                # Specifies the name of the NDK library that\n                # you want CMake to locate.\n                log )\n\ntarget_link_libraries( # Specifies the target library.\n                        native-lib\n                        jsc\n                        ${log-lib} )\n```\n\n## 'CoreFoundation/CoreFoundation.h' file not found\n\n出现这个问题，是因为我使用的头文件不对。之前编译出来的 jsc 的头文件有问题，得到的可能是 macOS 下的头文件。\n\n我换了一份头文件可以成功编译了，正确的头文件是不包含 CoreFoundation 依赖的。\n\n## 编写 JNI\n\n下面来到 native-lib.cpp，加入以下代码：\n\n``` c++\n#include <jni.h>\n#include <string>\n\n#include \"JavaScriptCore/JavaScript.h\"\n\nstd::string JSStringToStdString(JSStringRef jsString) {\n    size_t maxBufferSize = JSStringGetMaximumUTF8CStringSize(jsString);\n    char* utf8Buffer = new char[maxBufferSize];\n    size_t bytesWritten = JSStringGetUTF8CString(jsString, utf8Buffer, maxBufferSize);\n    std::string utf_string = std::string(utf8Buffer, bytesWritten - 1);\n    delete [] utf8Buffer;\n    return utf_string;\n}\n\nextern \"C\" JNIEXPORT jstring\n\nJNICALL\nJava_com_maxiee_jsclearning1_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n    JSContextGroupRef contextGroup = JSContextGroupCreate();\n    JSGlobalContextRef globalContext = JSGlobalContextCreateInGroup(contextGroup, nullptr);\n\n    JSStringRef statement = JSStringCreateWithUTF8CString(\n            \"function degToRad(value) {return (value * Math.PI) / 180; } ('90 deg = ' + degToRad(90))\");\n\n    JSValueRef retValue = JSEvaluateScript(globalContext, statement, nullptr, nullptr, 1, nullptr);\n\n    JSStringRef retString = JSValueToStringCopy(globalContext, retValue, nullptr);\n\n    std::string hello = JSStringToStdString(retString);\n\n    JSGlobalContextRelease(globalContext);\n    JSContextGroupRelease(contextGroup);\n    JSStringRelease(statement);\n    JSStringRelease(retString);\n\n    return env->NewStringUTF(hello.c_str());\n}\n```\n\n其中：\n\n-   此时的头文件和类型都是访问不到的，在 IDE 中与 jsc 相关的都是标红状态。\n\n## 运行\n\n当成功连接后，编译 App，可以看到成功运行了一个 JavaScript 方法，并在屏幕上展示结果：\n\n![](image/device-2018-12-21-151824.png)\n\n## 结论\n\n通过这次实践，虽然最终把代码跑起来了，但整个过程中懵懵懂懂，还是非常模糊。下一步要做的，是把概念不清晰的地方搞明白。\n\n## 网络资源\n\n本文参考了以下文章：\n\n-   [Running Javascript in Android app or game with JavaScriptCore and Native code](https://medium.com/@ntchung/running-javascript-in-android-app-or-game-with-javascriptcore-and-native-code-221f7466852d)\n\n"},"path":"post/JavaScriptCoreAndroidRunmd"}
