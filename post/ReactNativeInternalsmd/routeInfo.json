{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native Internals（翻译）","desc":"React Native 看起来像是黑魔法，为了理解其中原理，让我们看看 React Native 的架构与内部工作方式。","type":"md","link":"ReactNativeInternalsmd","create":"2019-03-07","filename":"ReactNativeInternals.md"},"content":"## 前言\n\n本文源链接为 [React Native Internals](https://www.reactnative.guide/3-react-native-internals/3.1-react-native-internals.html)，我将其翻译为中文。\n\nReact Native 是一个允许开发者使用 JavaScript 构建原生应用的框架。\n\n等等！Cordova 不是很早就这么做了吗。为啥要用RN， 有啥特别的？\n\nRN 与基于 Cordova 的应用的主要差别在于：\n\n- 基于 Cordova 的应用运行在 WebView 中\n- RN 则直接访问移动操作系统提供的原生 API 和 View\n- 因此，RN 应用拥有与原生应用一致的体验与性能\n\n首先，直观会设想的是 React Native 将 JS 代码编译到对应的原生代码。\n\n但是这很难实现，因为 Java 和 Objective C 都是强类型语言，而 JavaScript 是弱类型的。\n\nReact Native 没有这么做，而是通过一种更聪明的方式。\n\n从本质上，React Native 可以看做是一组 React 组件，其中每个组件对应于相应的视图和组件。\n\n例如，一个原生的 TextInput 会有一个 RN 组件与之对应，可以在 JS 中直接导入，就像使用普通 React 组件一样。\n\n因此，开发者可以向开发普通 React Web APP 那样来开发原生应用。\n\n好吧，这看起来像是黑魔法 🙄。\n\n为了理解其中原理，让我们看看 React Native 的架构与内部工作方式。\n\n## 架构 🤖\n\niOS 与 Android 的架构是类似的，但是有细微差异。\n\n如果我们从整体来看，RN 平台主要分为三部分：\n\n1. **Native Code/Modules**：\n    - 大多数原生代码在 iOS 使用 Objective C 或 Swift 编写，在 Android 使用 Java 编写\n    - 但是对于写 React Native APP 来说，我们可能都不需要写 iOS 或 Android 的原生代码\n\n2. **Javascript VM**：\n\n    - 我们的 JavaScript 代码由 JS 虚拟机运行\n    - React Native 使用 JavaScriptCore 运行 iOS/Android 虚拟机和设备中的代码，JavaScriptCore 也是驱动 Safari 的 JavaScript 引擎\n    - JavaScriptCore 是一个开源的 JavaScript 引擎，最初是为 WebKit 开发的\n    - 在 iOS 平台上，React Native 使用系统提供的 JavaScriptCore。它最初是与 OS X Mavericks 一起被引入iOS 7 的。https://developer.apple.com/reference/javascriptcore\n    - 在 Android 平台，应用会把 JavaScriptCore 打包在内。这回增大包体积。因此一个 RN 的 HelloWord 应用，在 Android 上也得 3~4 MB\n    - 在 Chrome Debug 模式的时候，JavaScript 代码会在 Chrome 中运行（而不是设备上的 JavaScriptCore），并且通过 WebSocket 与原生代码通信。因此这会使用 V8 引擎。这样，我们就能使用 Crhome 的调试工具看到许多信息，比如网络请求，命令行日志等等。😎\n\n3. **React Native Bridge**：React Native Bridge 是 C++/Java bridge，负责 Native 线程与 Java 线程间的通信。使用定制的协议传递消息。\n\n    ![](image/ReactNativeInternals1.png)\n\n    在大多数情况下，开发者会使用 JavaScript 来编写整个应用。\n\n    通过以下命令行语句来运行程序：\n\n    ```\n    react-native run-ios\n    \n    react-native run-android\n    ```\n\n    此时，React Native Cli 会创建一个 node 打包器（metro bundler），它会将  JS 代码打包为一个单个的 main.bundle.js 文件。\n\n    这个打包器可以被看做是类似 Webpack。\n\n    现在，当 React Native 应用被启动时，首先被加载的是原生入口点（native entry point）。\n\n    Native 线程会创建 JS VM 线程，并运行打包后的 JS 代码。JS 代码中包含应用的所有业务逻辑。\n\n    Native 线程现在通过 RN Bridge 发送消息，来启动 JS 应用。\n\n    指令包括加载哪些视图，从硬件中获取哪些信息等等。\n\n    例如，如果 JS 线程想要创建一个 VIew 和 Text，它会将请求打包为一个单条的消息，发送到 Native 线程并进行实际展示。\n\n    ```\n    [ [2,3,[2,'Text',{...}]] [2,3,[3,'View',{...}]] ]\n    ```\n\n    Native 线程会处理这些操作，并将结果返回给 JS，以确保操作已被完成执行。\n\n    **注意：**如果想在 Console 中查看 bridge 消息，只需要在 `index.<platform>.js` 中加入以下代码：\n\n    ```js\n    import MessageQueue from 'react-native/Libraries/BatchedBridge/MessageQueue';\n    MessageQueue.spy(true);\n    ```\n\n## 线程模型 🚧\n\n当 React Native 应用被启动时，它会创建一下线程队列：\n\n1. **Main thread** *（Native Queue）*：\n    - 这是应用启动时就立刻创建的主线程\n    - 它加载 APP 并启动 JS 线程来执行 JavaScript 代码\n    - Native 线程还监听 UI 事件，例如”按下“、”触摸“等等。这些事件会通过 RN Bridge 被传递到 JS 线程\n    - 一旦 JavaScript 加载起来，JS 线程会通过消息方式发送屏幕上要展示的内容\n    - 这个信息被 **shadow node thread** 使用，来计算布局\n    - shadow thread 从根本上说是一个数学引擎，来最终决定视图的位置该如何计算\n    - 这些指令最终传回主线程，并进行实际展示\n2. **Javascript thread** *(JS Queue)* ：\n    - JavaScript 线程队列是主 JS 包被执行的线程\n    - JS 线程执行所有的业务逻辑，也就是我们编写的 React Native 业务代码\n3. **Custom Native Modules**\n    - 除了 React Native 创建的线程外，我们还可以在自己创建的自定义模块中创建线程，以加快应用程序的性能\n    - 例如：动画在 React Native 中交由一个单独的 native 线程来处理，以分担 JS 线程的工作\n\n链接：https://www.youtube.com/watch?v=0MlT74erp60\n\n## View Managers 👓\n\nView Managers 是 Native Module，它将 JSX 视图映射到 Native Views。例如：\n\n```jsx\nimport React, { Component } from \"react\";\nimport { Text, View, AppRegistry } from \"react-native\";\n\nclass HelloWorldApp extends Component {\n  render() {\n    return (\n      <View style={{ padding: 40 }}>\n        <Text>Hello world!</Text>\n      </View>\n    );\n  }\n}\n\nexport default HelloWorldApp;\nAppRegistry.registerComponent(\"HelloWorldApp\", () => HelloWorldApp);\n```\n\n其中：\n\n- 当我们写下 `<Text/>`，如果实在 Android 平台，Text View manager 会调用 `new TextView(getContext())`\n\n在 Android 平台，View Managers 都是继承自 `ViewManager` 的类，在 iOS 则是继承自 `RCTViewManager`。\n\n## 开发模式 🔨\n\n当 APP 在 `DEV` 模式运行时 JavaScript 线程在开发机（电脑）上被创建。\n\n尽管 JS 代码在电脑上运行的性能比手机上高，但是你会注意到实际性能比 bundled 模式或者 production 模式还要慢。\n\n这是因为在 DEV模式下，在运行时要做许多额外工作，来提供更好的警告与错误信息，例如验证 propTypes 以及其它的断言。\n\n此外，设备与 JS 之间的通信延迟也是导致慢的原因。\n\n链接：<https://www.youtube.com/watch?v=8N4f4h6SThc> - RN android architecture\n\n## React Native 的新架构（Fabric）\n\nReact Native 团队目前正在为 React Native 开发一个新架构。\n\n新架构的代号为 Fabric，将会允许 React Native 以同步方式执行高优先级的 UI 更新。\n\n这意味着 UI 在某些极限情况（Edge Cases）下会更灵敏（比如滚动视图）。\n\n想要了解 Fabric 以及它到底如何提升 React Native 的话，请观看 Parashuram N 在 React Conf 2018 上的精彩演讲。https://www.youtube.com/watch?v=UcqRXTriUVI"},"path":"post/ReactNativeInternalsmd"}
