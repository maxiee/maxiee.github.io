{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"Maxiee 的 RxJava 学习指南 (3) - UI 交互","desc":"RxJava 学习系列","type":"md","link":"Rxjava3md","create":"2017-06-13","filename":"Rxjava3.md"},"content":"## 介绍\n\n在这一篇中, 我将继续对 [RxJava-Android-Samples](https://github.com/kaushikgopal/RxJava-Android-Samples) 项目的学习, 主要包含以下 3 个 Demo:\n\n- Accumulate Calls\n- Search Text Listener\n- Double Binding\n\n这 3 个 Demo 都是与 UI 相关的, 包括监听控件的事件, 以及比较流行的 Data Binding. 通过学习, 我们将会学到如何将 RxJava 应用到界面开发中.\n\n## Accumulate Calls\n\n这个 Demo 位于 BufferDemoFragment. 它的界面和说明如下:\n\n| 截图                                       | 说明                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| ![60439BB7-C896-4858-8E16-4AFBA428608E](http://7xohx8.com1.z0.glb.clouddn.com/60439BB7-C896-4858-8E16-4AFBA428608E.png) | 功能是统计 2s 内点击按钮的次数. 每次点击会立即展示一个 \"GOT A TAP\", 等 2s 结束后会显示者两秒内点击的次数. |\n\n下面来看具体的代码:\n\n```java\nRxView.clicks(_tapBtn)\n    .map(\n        onClickEvent -> {\n            _log(\"GOT A TAP\");\n            return 1;\n        })\n    .buffer(2, TimeUnit.SECONDS)\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribeWith(\n        new DisposableObserver<List<Integer>>() {\n\n            @Override\n            public void onComplete() {}\n\n            @Override\n            public void onError(Throwable e) {}\n\n            @Override\n            public void onNext(List<Integer> integers) {\n            if (integers.size() > 0) {\n                _log(String.format(\"%d taps\", integers.size()));\n            } else {\n                Timber.d(\"--------- No taps received \");\n            }\n        }\n    });\n```\n\n从代码中可以看到, 在按钮上面套了一层 `RxView.clicks`. 这里用到了 jakewharton 大神的 [RxBinding 库](https://github.com/JakeWharton/RxBinding).\n\n这个库我打算在下一篇博客中详细介绍, 在这里只需知道对 Button 使用 `RxView.clicks(_tapBtn)` 包一下就将 Button 的点击变成了一个被观察者.\n\n除此之外, 在上面代码中主要使用了 buffer 操作符, 它起了关键地作用, 下面来详细看一下.\n\n### Buffer 操作符\n\n其中的关键就在与 Buffer 这个操作符, 首先介绍一下它.\n\nBuffer 操作符的官方文档在[这里](http://reactivex.io/documentation/operators/buffer.html), 它的描述为:\n\n> 周期性地收集被观察者发出的数据, 打成一个包 (一个列表), 将这个包发出去.\n\n具体来说, 就是 Buffer 每隔一定周期收集源被观察者发出的数据, 将它打包成一个列表, 对外发出.\n\n因此, 上述代码的大体流程, 使用 RxJava 的弹珠图来梳理为:\n\n![20119938-FD5F-42FC-BA5C-F28A47A74AED](http://7xohx8.com1.z0.glb.clouddn.com/20119938-FD5F-42FC-BA5C-F28A47A74AED.png)\n\n其中:\n\n- 多次点击按钮多发出多个 click 事件, 传入 buffer, \n- `buffer(2, TimeUnit.SECONDS)` 表示定时的周期为 2s \n- 一单时间到, buufer 将这段时间里收到的数据, 打包成一个列表传出去\n- `onNext` 的参数是 `List<Integer> integers` 它的长度表示这段时间内点击按钮的次数\n\n## Search Text Listener\n\n这个 Demo 位于 DebounceSearchEmitterFragment. 它的界面跟说明如下:\n\n| 截图                                       | 说明                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| ![3183F061-BA58-4D63-B6D3-FA57B75122FA](http://7xohx8.com1.z0.glb.clouddn.com/3183F061-BA58-4D63-B6D3-FA57B75122FA.png) | 我们在输入框中输入文本, 当我们输入停下来的时候, 会自动在下方添加一条 \"Searching for …\" 的记录. |\n\n对应的实现代码为:\n\n```java\n_disposable =\n    RxTextView.textChangeEvents(_inputSearchText)\n        .debounce(400, TimeUnit.MILLISECONDS) // default Scheduler is Computation\n        .filter(changes -> isNotNullOrEmpty(changes.text().toString()))\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribeWith(_getSearchObserver());\n```\n\n其中, EditText 被套了一个 `RxTextView.textChangeEvents`, 这个还是 [RxBinding 库](https://github.com/JakeWharton/RxBinding) 中的方法, 将 EditText 变成了一个被观察者, 每当文本变化, 会发出事件. \n\n除此, 最重要的是用了一个 debounce 操作符, 下面来详细看一下.\n\n### Debounce 操作符\n\nDebounce 的文档在[这里](http://reactivex.io/documentation/operators/debounce.html), 它的描述为:\n\n> 给定一个事件间隔, 对外发射在这段时间间隔里, 发出所收到数据的最后一个.\n\n这里要注意的一点是: \n\n> 假设被观察者已经发出一个数据传入 Debounce, 此时它会开始计时, 如果在计时时间结束之前又有一个数据传入 Debounce, 这时 Debounce 会重新开始计时\n\n我们结合上面的代码来理解这段描述:\n\n- 首先, 每向 EditText 中打一个字符, 都会触发被观察者对外发射一个数据\n- 所发出的数据会传入 Debounce\n- 如果我们连续打字, 连续有数据传入 Debounce, 这时 Debounce 不断重置计时器\n- 一旦我们停止输入, 过了 400ms, Debounce 会对外输出最后一次的数据\n- 传给下一个 filter 操作符 (实现判空过滤功能)\n\n这样, 我们通过 Debounce 操作符, 就为 EditText 提供了能够动态感知输入结束的能力.\n\n下面我们再来看 filter 的作用.\n\n### Filter 操作符\n\nFilter 的文档在[这里](http://reactivex.io/documentation/operators/filter.html), 它的描述为:\n\n> Filter 操作符接收一个方法, 这个方法是一个条件判断. 对于传入 Filter 的数据, 都传入这个方法里判断一下是否满足条件.\n>\n> 如果满足条件则对外发出, 如果不满足条件, 则不发出.\n\n这样, 结合上面的代码不难看出, 将 Debounce 输出的数据传入 Filter, 目的是加入对 EditText 的判空检查.\n\n如果 EditText 的内容是空的, Filter 就将它过滤掉, 不再对外发出了.\n\n### 小结\n\n在了解了 Debounce 和 Filter 两个操作符的功能后, 我们就完全弄明白了这个 Demo 中 EditText 够动态感知输入结束的原理了.\n\n## Double Binding\n\n这个 Demo 位于 DoubleBindingTextViewFragment. 它的界面和截图如下:\n\n| 截图                                       | 说明                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| ![4D7EF063-7D03-4B4B-9672-E75E1F0E47B0](http://7xohx8.com1.z0.glb.clouddn.com/4D7EF063-7D03-4B4B-9672-E75E1F0E47B0.png) | 界面中有两个用于输入数字的 EditText, 当我们改变其中的一个的值, 下方的和就会自动变化. |\n\n这个功能是怎么实现的呢?\n\n首先我们通过 ButterKnife 监听两个 EditText 的 OnTextChanged 事件:\n\n```java\n@OnTextChanged({R.id.double_binding_num1, R.id.double_binding_num2})\npublic void onNumberChanged() {\n    ...\n}\n```\n\n这个是 ButterKnife 提供的特性, 跟 RxJava 无关, 跟 RxJava 有关的在方法的实现里, 它的实现为:\n\n```java\n@OnTextChanged({R.id.double_binding_num1, R.id.double_binding_num2})\npublic void onNumberChanged() {\n    float num1 = 0;\n    float num2 = 0;\n\n    if (!isEmpty(_number1.getText().toString())) {\n        num1 = Float.parseFloat(_number1.getText().toString());\n    }\n\n    if (!isEmpty(_number2.getText().toString())) {\n        num2 = Float.parseFloat(_number2.getText().toString());\n    }\n\n    _resultEmitterSubject.onNext(num1 + num2);\n}\n```\n\n其中:\n\n- 当 EditText 内容变化, 就会调用 onNumberChanged\n- 我们拿出两个 EditText 的值\n- 对两个值相加, 作为数据传入 `_resultEmitterSubject`\n\n现在的问题是 `_resultEmitterSubject` 是什么呢? 我们来看它的创建的代码:\n\n```java\n_resultEmitterSubject = PublishProcessor.create();\n```\n\n从中可以看出, 它是一个 `PublishProcessor`.\n\n可是问题又来了, `PublishProcessor` 是什么呢?\n\n### PublishProcessor\n\n对这部分的讲解记录在 [What's different in 2.0](https://github.com/ReactiveX/RxJava/wiki/What%27s-different-in-2.0) 的 Subjects and Processors 一节.\n\n还记得第一篇中介绍过 ReactiveX 中的 Subject 的概念, 它在 RxJava 2.0 中细分为两种:\n\n- Subject 不支持背压\n- Process 支持背压\n\n对于背压这个概念, 我还不太明白. 那么暂且在这里就把 PublishProcessor 当做 PublishSubject 来看待吧.\n\n### 订阅\n\n先梳理一下前面的流程, 如下图所示:\n\n![49661D54-5CC7-4156-BD3A-5B5B77952636](http://7xohx8.com1.z0.glb.clouddn.com/49661D54-5CC7-4156-BD3A-5B5B77952636.png)\n\n其中, 我们已经分析了 `OnTextChanged`, 调用 `_resultEmitterSubject` 的 `onNext`. 现在还剩下最后一步, 就是观察者订阅 `_resultEmitterSubject` 接收数据, 这部分的实现代码为:\n\n```java\n_disposable =\n    _resultEmitterSubject.subscribe(\n        aFloat -> {\n            _result.setText(String.valueOf(aFloat));\n        });\n```\n\n这个很简单, 就是收到前面过程传入的合值, 在结果 TextView 中进行显示.\n\n## 总结\n\n至此, 我们就完成了对 3 个 Demo 的学习.\n\n可以看出, 结合 RxJava 进行界面开发, 代码是比较优雅的, 尤其是在实现一些对控件的扩展操作, 例如 throttling 和监听输入.\n\n在学习中我们还看到, jakewharton 大神的 [RxBinding 库](https://github.com/JakeWharton/RxBinding)为开发提供了很多便利.\n\n这个库的功能十分强大, 在下一篇的学习中, 我将对这个库进行详细地学习."},"path":"post/Rxjava3md"}
