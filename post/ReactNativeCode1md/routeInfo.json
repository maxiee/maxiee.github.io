{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（一）：启动流程（Android）","desc":"React Native 代码阅读系列第一篇，从集成 React Native 框架入手，深入分析 RN 的启动流程。","type":"md","link":"ReactNativeCode1md","create":"2019-01-29","filename":"ReactNativeCode1.md"},"content":"## 介绍\n\n在 Android 工程中集成 React Native 是很容易的，核心代码如下：\n\n```java\npublic class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler {\n    private ReactRootView mReactRootView;\n    private ReactInstanceManager mReactInstanceManager;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        mReactRootView = new ReactRootView(this);\n        mReactInstanceManager = ReactInstanceManager.builder()\n                .setApplication(getApplication())\n                .setBundleAssetName(\"index.android.bundle\")\n                .setJSMainModulePath(\"index\")\n                .addPackage(new MainReactPackage())\n                .setUseDeveloperSupport(BuildConfig.DEBUG)\n                .setInitialLifecycleState(LifecycleState.RESUMED)\n                .build();\n        // The string here (e.g. \"MyReactNativeApp\") has to match\n        // the string in AppRegistry.registerComponent() in index.js\n        mReactRootView.startReactApplication(mReactInstanceManager, \"MyReactNativeApp\", null);\n\n        setContentView(mReactRootView);\n    }\n\n    @Override\n    public void invokeDefaultOnBackPressed() {\n        super.onBackPressed();\n    }\n}\n```\n\n其中主要分为以下几步：\n\n1.  创建 ReactRootView\n2.  创建 ReactInstanceManager\n3.  两者绑定初始化\n\n还有一点需注意的是：startReactApplication 的第二个参数 \"MyReactNativeApp\"，它与 React Native App 的 index.js 中注册的 Register 名需是一致的。\n\n下面来分别来看。\n\n## 创建 ReactRootView\n\n### Catalyst APP\n\n如果看 ReactRootView 的代码，会发现其中有一个名词——Catalyst APP，催化剂应用。我们只知道有原生应用、React Native 应用，这里的催化剂应用是什么呢？\n\n对此我的理解是，Catalyst 是一个 Framework，它的作用是对 Native 进行改造，以供运行 React Native 应用。这种改造的过程像不像化学中的催化剂，驱使一种物质改变为另一种物质。\n\n### 构造函数\n\n前文中首先构造 ReactRootView 实例：\n\n```java\nmReactRootView = new ReactRootView(this);\n```\n\n因此先看它的构造函数：\n\n```java\npublic ReactRootView(Context context) {\n  super(context);\n}\n\npublic ReactRootView(Context context, AttributeSet attrs) {\n  super(context, attrs);\n}\n\npublic ReactRootView(Context context, AttributeSet attrs, int defStyle) {\n  super(context, attrs, defStyle);\n}\n```\n\n我们发现构造中什么都没做，只是进行了默认的 View 初始化工作。\n\n由此可以推测，主要的工作都是在这行进行了：\n\n```java\nmReactRootView.startReactApplication(mReactInstanceManager, \"MyReactNativeApp\", null);\n```\n\n## 创建 ReactInstanceManager\n\n### ReactInstanceManager\n\n这个类管理 CatalystInstance 的实例。他通过 ReactPackage 对外暴露一种设置 catalyst 实例的方式，并且跟踪实例的生命周期。他还在实例与开发者支持功能之间建立一个关联。\n\n需要建立 ReactInstanceManager 的实例之后才能启动 ReactRootView 中的 JS 应用。\n\n### 构造者模式\n\nReactInstanceManager 类中的成员非常多，因此它使用构造者模式进行初始化：\n\n```java\nmReactInstanceManager = ReactInstanceManager.builder()\n        .setApplication(getApplication())\n        .setBundleAssetName(\"index.android.bundle\")\n        .setJSMainModulePath(\"index\")\n        .addPackage(new MainReactPackage())\n        .setUseDeveloperSupport(BuildConfig.DEBUG)\n        .setInitialLifecycleState(LifecycleState.RESUMED)\n        .build();\n```\n\n其中，传入了：\n\n| 项目                     | 说明                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| Application              | App 的 Application 实例                                      |\n| setBundleAssetName       | JS Bundle 文件的名称                                         |\n| setJSMainModulePath      | 在打包服务器中 APP 主模块的路径，这个用于开发过程中重新加载 JS，所有路径都相对于打包程序提供文件的根文件夹。举例：\"index.android\"、\"subdirectory/index.android\" |\n| addPackage               | 添加一个 ReactNative 包                                      |\n| setUseDeveloperSupport   | 是否支持开发者调试                                           |\n| setInitialLifecycleState | 初始生命周期                                                 |\n\n### build()\n\n在上一节中最后调用了 build()，构造出 ReactInstanceManager 实例。\n\n我们先忽略 ReactInstanceManager 构造函数中的细节。\n\n可以简单的理解为：\n\n-   ReactInstanceManager 保存了我们在 Builder 中设置的参数\n-   构造了一个 ReactInstanceManager 实例\n\n## 绑定\n\n### mReactRootView.startReactApplication\n\n我们将重点放在两者的绑定上面：\n\n```java\nmReactRootView.startReactApplication(mReactInstanceManager, \"MyReactNativeApp\", null);\n```\n\n下面来看 mReactRootView.startReactApplication 的实现，我们只看它的核心逻辑。\n\n主要分为三步：\n\n1.  参数保存\n2.  ReactInstanceManager 初始化\n3.  ReactInstanceManager attachRootView\n\n对应的核心代码为：\n\n1. Step1 参数保存：\n\n    首先把传入的参数保存下来：\n\n    ```java\n    mReactInstanceManager = reactInstanceManager;\n    mJSModuleName = moduleName;\n    mAppProperties = initialProperties;\n    ```\n\n    注意：\n\n    -   现在 ReactRootView 已经持有 ReactInstanceManager 的实例了。\n\n2. Step2 初始化 ReactInstanceManager Context\n\n  ```java\n    if (!mReactInstanceManager.hasStartedCreatingInitialContext()) {\n        mReactInstanceManager.createReactContextInBackground();\n    }\n  ```\n\n    其中：\n\n    -   if 判断防止重复初始化 ReactInstanceManager\n\n3. Step3 ReactInstanceManager attachRootView\n\n    之后调用：\n\n    ```java\n    Assertions.assertNotNull(mReactInstanceManager).attachRootView(this);\n    ```\n\n    这句可以简化为：\n\n    ```java\n    mReactInstanceManager.attachRootView(this);\n    ```\n\n    单看这一句，我们大概可以猜出，ReactInstanceManager 很可能也持有了 ReactRootView 的实例，因此他们两者很可能是相互持有的。\n\n### ReactInstanceManager Context 初始化\n\n下面我们一步一步来分析上面三步中所调用方法的内部。\n\nReactInstanceManager 初始化所调用的代码为：\n\n```java\nif (!mReactInstanceManager.hasStartedCreatingInitialContext()) {\n    mReactInstanceManager.createReactContextInBackground();\n}\n```\n\n我们来看 createReactContextInBackground 中的核心逻辑:\n\n```java\nmHasStartedCreatingInitialContext = true;\nrecreateReactContextInBackgroundInner();\n```\n\n其中：\n\n-   首先它反转了一个标志位，表示已经开始初始化 Context 了\n-   之后调用了内部方法，我们跟进这个方法\n\nrecreateReactContextInBackgroundInner 内部是比较复杂的，主要分为两步：\n\n-   如何加载包\n-   创建 ReactContext\n\n这里我们先忽略第一步，着重看第二步。加载包的过程将会在后续系列中单独梳理。\n\n跳过加载包的过程，走到这一行代码：\n\n```java\nrecreateReactContextInBackgroundFromBundleLoader();\n```\n\n我们进入这个方法来看：\n\n```java\nrecreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);\n```\n\n其中：\n\n-   使用两个成员 mJavaScriptExecutorFactory，mBundleLoader 来调用 recreateReactContextInBackground\n\n我们先来看，这两个成员是如何传入 ReactInstanceManager 的。\n\n暂时回到 ReactInstanceManagerBuilder 中的 build() 方法：\n\n-   如果我们在 Builder 中没有 set 过 mJavaScriptExecutorFactory，则会创建一个默认 JSCJavaScriptExecutorFactory 实例\n-   如果我们在 Builder 中没有 set 过 mJSBundleLoader，则会创建一个默认的 JSBundleLoader 实例\n-   这两个实例会随构造函数传入 ReactInstanceManager\n\n好了，回到 recreateReactContextInBackground，我们接着看：\n\n首先创建了一个 ReactContextInitParams：\n\n```java\nfinal ReactContextInitParams initParams = new ReactContextInitParams(\n    jsExecutorFactory,\n    jsBundleLoader);\n```\n\n其中：\n\n-   我们可以看出 ReactContext 专门有一个 InitParams 类来进行初始化\n\n之后执行：\n\n```java\nrunCreateReactContextOnNewThread(initParams);\n```\n\n从方法名我们能够看出，这一步会创建 ReactContext，并创建一个新线程。\n\n### ReactInstanceManager Context 初始化 2\n\n我们进入 runCreateReactContextOnNewThread 接着看。\n\n这个方法内创建并启动了一个线程：\n\n```java\nmCreateReactContextThread =\n    new Thread(\n        new Runnable() {\n            @Override\n            public void run() {\n                ...\n            }\n        });\nmCreateReactContextThread.start();\n```\n\n其中：\n\n-   通过线程的构造函数传入一个 Runnable\n-   Runnable 会在线程 start 后执行\n-   我们的逻辑都写在 Runnable 里\n\n下面我们来看 Runnable 中的核心逻辑：\n\n首先反转标志位：\n\n```java\nmHasStartedCreatingInitialContext = true;\n```\n\n之后创建 ReactContext：\n\n```java\nfinal ReactApplicationContext reactApplicationContext =\n    createReactContext(\n        initParams.getJsExecutorFactory().create(),\n        initParams.getJsBundleLoader());\n```\n\n终于走到了这一步，可以看出，具体的创建过程都在 createReactContext 方法中。我们这里先继续分析 Runnable 逻辑。\n\n在 createReactContext 之后还做了两件事情：\n\n1.  设置 reactApplicationContext\n2.  向这个主线程再扔一个 Runnable，如果 mPendingReactContextInitParams 不为空，则重新创建 ReactContext\n\n其中，我们主要关注第一步：\n\n```java\nRunnable setupReactContextRunnable =\n    new Runnable() {\n    @Override\n    public void run() {\n        try {\n        setupReactContext(reactApplicationContext);\n        } catch (Exception e) {\n        mDevSupportManager.handleException(e);\n        }\n    }\n    };\n\nreactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);\n```\n\n其中：\n\n-   调用 setupReactContext 方法来设置 ReactContext，我们将在后面分析\n-   这个 runnable 是扔到 reactApplicationContext 的 `NativeModulesQueueThread` 上面去执行\n-   从中我们可以察觉，reactApplicationContext 里面还发起了线程\n\n在下文中，我们先分析 createReactContext 看看 ReactContext 具体是怎么创建的，再分析 setupReactContext。\n\n## ReactContext 的创建与绑定\n\n### createReactContext\n\n先回顾一下 createReactContext 的方法签名：\n\n```java\nprivate ReactApplicationContext createReactContext(\n    JavaScriptExecutor jsExecutor,\n    JSBundleLoader jsBundleLoader) {\n```\n\n首先我们直接 new 出了 ReactApplicationContext 实例：\n\n```java\nfinal ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext);\n```\n\nReactApplicationContext 我们将在下一节中来看。这里先把 createReactContext 过程分析完。\n\n之后这一步非常非常关键：\n\n```java\nNativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n```\n\n其中：\n\n-   我们创建了 NativeModuleRegistry，它是专门管理 Native 包的\n-   包加载的功能我们放在后续文章中集中分析，在本文中，我们还是核心关注 React Native 自身的启动流程\n\n之后创建了 CatalystInstanceImpl 的构造器：\n\n```java\nCatalystInstanceImpl.Builder catalystInstanceBuilder = new CatalystInstanceImpl.Builder()\n    .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())\n    .setJSExecutor(jsExecutor)\n    .setRegistry(nativeModuleRegistry)\n    .setJSBundleLoader(jsBundleLoader)\n    .setNativeModuleCallExceptionHandler(exceptionHandler);\n\n...\n\nfinal CatalystInstance catalystInstance;\ntry {\n    catalystInstance = catalystInstanceBuilder.build();\n} finally { ...}\n```\n\n这个类光看它的构造参数就可知道，这是一个很重要的类。\n\n之后是对 CatalystInstance 的一些设置，我们暂且省略，于是来到了这一句：\n\n```java\ncatalystInstance.runJSBundle();\n```\n\n这一句非常的重要！我们的 JS 包是通过这一句来加载执行的。关于包的运行与加载我们放在后面文章中来梳理，从中可以看出，随着框架的加载，已经开始进入到包的加载与运行阶段了，我们后文主题的线索也开始多起来。\n\ncreateReactContext 中最后还有一句：\n\n```java\nreactContext.initializeWithInstance(catalystInstance);\n```\n\n这个方法调用了 ReactContext.initializeWithInstance。这个方法我们放到下一节，梳理完 ReactApplicationContext 后，再来看它。\n\n### ReactApplicationContext\n\nReactApplicationContext 类本身非常简单，只是对 ReactContext 的简单继承：\n\n```java\npublic class ReactApplicationContext extends ReactContext {\n  public ReactApplicationContext(Context context) {\n    super(context.getApplicationContext());\n  }\n}\n```\n\n我省略了代码中的注释，注释中说到为什么要封装这么一个类。主要是为了在构造函数里面，将传入的 Context 通过 getApplicationContext，保证始终取到的是 Application。\n\n从中也可以看出，ReactContext 才是重头戏。\n\n### ReactContext\n\n1.  介绍\n\n    ReactContext 是 React Native 在 Java 层最核心的一个类。CatalystInstance、消息队列都是它的成员。\n\n2. 构造函数\n\n    ReactContext 的构造函数是空的：\n\n    ```java\n    public ReactContext(Context base) {\n        super(base);\n    }\n    ```\n\n3. initializeWithInstance\n\n    在前文 createReactContext 中最后一句调用的就是 initializeWithInstance，我们现在来看，它是 ReactContext 初始化的核心方法。\n\n    先回忆下方法签名：\n\n    ```java\n    public void initializeWithInstance(CatalystInstance catalystInstance) {\n    ```\n\n    首先我们把它存下来，作为成员变量：\n\n    ```java\n    mCatalystInstance = catalystInstance;\n    ```\n\n    之后我们从 catalystInstance 里面搞出来两个线程：\n\n    ```java\n    ReactQueueConfiguration queueConfig = catalystInstance.getReactQueueConfiguration();\n    mUiMessageQueueThread = queueConfig.getUIQueueThread();\n    mNativeModulesMessageQueueThread = queueConfig.getNativeModulesQueueThread();\n    mJSMessageQueueThread = queueConfig.getJSQueueThread();\n    ```\n\n    其中：两个线程是怎么搞出来的？\n    先看：\n\n        ReactQueueConfiguration queueConfig = catalystInstance.getReactQueueConfiguration();\n\n    进入 catalystInstance.getReactQueueConfiguration：\n\n    ```java\n    @Override\n    public ReactQueueConfiguration getReactQueueConfiguration() {\n        return mReactQueueConfiguration;\n    }\n    ```\n\n    可以看出，这是一个 getter 方法，mReactQueueConfiguration 是在哪里创建实例的呢？答案是在 CatalystInstanceImpl 的构造函数中：\n\n    ```java\n    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(\n        reactQueueConfigurationSpec,\n        new NativeExceptionHandler());\n    ```\n\n    进入 ReactQueueConfigurationImpl.create 再看一下。\n\n    我们简化它的具体细节，简化为 ReactQueueConfigurationImpl 中会创建 3 条线程：\n\n    -   uiThread\n    -   nativeModulesThread\n    -   jsThread\n\n    回到 initializeWithInstance 的代码：\n\n    ```java\n    ReactQueueConfiguration queueConfig = catalystInstance.getReactQueueConfiguration();\n    mUiMessageQueueThread = queueConfig.getUIQueueThread();\n    mNativeModulesMessageQueueThread = queueConfig.getNativeModulesQueueThread();\n    mJSMessageQueueThread = queueConfig.getJSQueueThread();\n    ```\n\n    我们可以看出，ReactContext 也把这三个线程取出来，作为自己的成员变量了。\n\n## ReactContext 创建之后\n\n### 介绍\n\n在前面的小节中，我们创建了 ReactContext，ReactContext 内部又创建了 CatalystInstance，CataLystInstance 内部又创建了多条线程……\n\nReactContext 创建完成后，框架的初始化过程并没有结束。\n\n回到 ReactRootView 的 startReactApplication 方法，在 createReactContextInBackground 完成之后，方法的末尾还有一句：\n\n```java\nattachToReactInstanceManager();\n```\n\n进入到方法中，核心是这一句：\n\n```java\nAssertions.assertNotNull(mReactInstanceManager).attachRootView(this);\n```\n\n它可以等同于：\n\n```java\nmReactInstanceManager.attachRootView(this);\n```\n\n### ReactInstanceManager.attachRootView\n\n我们进入 mReactInstanceManager.attachRootView，来看它的核心逻辑。\n\n首先它把传入的 ReactRootView 存了下来：\n\n```java\nmAttachedRootViews.add(rootView);\n```\n\n从中我们可以看出：\n\n-   ReactInstanceManager 是支持多 RootView 的\n\n之后 ReactInstanceManager 把 ReactRootView 给清了：\n\n```java\nrootView.removeAllViews();\nrootView.setId(View.NO_ID);\n```\n\n最后，取出 ReactContext，让 ReactRootView 与 CatalystInstance 相关联：\n\n```java\nReactContext currentContext = getCurrentReactContext();\nif (mCreateReactContextThread == null && currentContext != null) {\n    attachRootViewToInstance(rootView, currentContext.getCatalystInstance());\n}\n```\n\n### ReactInstanceManager.attachRootViewToInstance\n\n首先通过 UIManagerHelper 拿到 UIManager：\n\n```java\nUIManager uiManagerModule = UIManagerHelper.getUIManager(mCurrentReactContext, rootView.getUIManagerType());\n```\n\nUIManager 是什么呢？它有两个实现类：\n\n-   UIManager\n-   UIManagerModule\n\n我们来看后者，它的注释中说：这是一个原生模块，允许 JS 创建和更新原生视图。\n\n之后，将 rootView 注册进 UIManagerModule 中：\n\n```java\nfinal int rootTag = uiManagerModule.addRootView(rootView);\n```\n\n之后，rootView 会调用下面这句启动 JS 程序：\n\n```java\nrootView.invokeJSEntryPoint();\n```\n\n这是一个很重要的点，它是我们 JS Bundle 的执行入口。\n\n最后，我们又向主线程扔了一个 Runnable：\n\n```java\nUiThreadUtil.runOnUiThread(new Runnable() {\n    @Override\n    public void run() {\n    ...\n    rootView.onAttachedToReactInstance();\n    }\n});\n```\n\n其中，onAttachedToReactInstance 是我们关心的。\n\n### ReactInstanceManager.onAttachedToReactInstance\n\n在这个方法中，主要干了一件事情，就是初始化了触摸事件的分发：\n\n```java\nmJSTouchDispatcher = new JSTouchDispatcher(this);\nif (mRootViewEventListener != null) {\n    mRootViewEventListener.onAttachedToReactInstance(this);\n}\n```\n\n## 结论\n\n至此，我们就把 Android 集成 React Native 框架代码的内部流程完完整整地走了一遍。这一遍走的粒度很粗，其中有很多核心概念都没有深挖。\n\n但是对于初识来说这已经足够了，在本文中，我们弄清了 React Native 的大致启动过程，知道了都有哪些核心组件被创建，也知道了他们的交互过程和时序过程。\n\n这些分析为我们提供了很多线索，供之后进行更加深入地专题学习。\n\n"},"path":"post/ReactNativeCode1md"}
