{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（十一）：react-native link 的实现原理(Android)","desc":"在本文中，我们以 react-native link 命令为起点，通过深入挖掘，了解到原来 React Native 中还有 React Native Package Manager 项目，同时也分析了 react-native link 的实现原理，打开了它的神秘面纱。","type":"md","link":"ReactNativeCode11md","create":"2019-03-22","filename":"ReactNativeCode11.md"},"content":"## 前言\n\nreact-native link 是一个我们在开发中经常用到的命令，它的作用是将第三方库中的 Native Modules 引入 Native 工程。在 Android 中，引入 Native 需要修改 Gradle、Java 代码，这是如何实现的呢？\n\n另一点值得一提的是，React Native cli 已经从官方源中迁移出来了，成为一个社区维护的项目 [react-native-cli](https://github.com/react-native-community/react-native-cli)。拥抱社区是 React Native 今年的一项重点工作，未来 React Native 生态会变得更好玩。\n\n## React Native Package Manager\n\n### 介绍\n\nReact Native 的第三方库虽然使用 npm 分发并使用 npm/yarn 进行安装，但是对于带有 Native Modules 的模块细心的人可能会注意到，需要使用 react-native link 进行连接。\n\n其实，React Native 是由自己的包管理器的，名为 React Native Package Manager（rnpm），link 操作是 rnpm 的一部分。\n\nrnpm 曾经是一个[独立项目](https://github.com/rnpm/rnpm)，现在被整合进入了 React Native Core。\n\n因此，想要弄清 link 的操作，我们首先要了解 React Native Package Manager。\n\n### 背景\n\nReact Native 包与普通的前端包不同之处在于，React Native 包通常还包括 Android、iOS 原生代码。如何才能将原生代码成功连接到原生工程内呢？\n\nrnpm 就是来解决这个问题的\n\n### package.json.rnpm\n\nrnpm 对 package.json 进行了扩充。开发者在开发 rnpm 包时，在 package.json 通过添加 rnpm 字段来控制 rnpm 的行为。其中包含几个控制项。\n\n#### commands\n\n用于添加在连接前后执行的命令：\n\n```json\n\"rnpm\": {\n  \"commands\": {\n    \"prelink\": \"./bin/requestGAToken\",\n    \"postlink\": \"./bin/linkingSucceeded\"\n  }\n}\n```\n\n#### assets\n\n用于指定需要连接进入工程的资源目录：\n\n```json\n...\n\"rnpm\": {\n  \"assets\": [\"Fonts\"]\n},\n...\n```\n\n### 如何解析 rnpm 资源\n\npackage.json 的 rnpm 字段是如何被解析的呢？\n\n让我们回到 react-native-cli 的代码，它位于 packages/cli/src/tools/getPackageConfiguration.js：\n\n```js\n/**\n * Returns configuration of the CLI from `package.json`.\n */\nexport default function getPackageConfiguration(\n  folder: string,\n): PackageConfigurationT {\n  return require(path.join(folder, './package.json')).rnpm || {};\n}\n```\n\n其中：\n\n- require 像导入普通的 json 一样，将 package.json 导入\n- 之后访问它的 rnpm 字段\n\n我们直接看它的返回类型 PackageConfigurationT：\n\n```js\n/**\n * Configuration of the CLI as set by a package in the package.json\n */\nexport type PackageConfigurationT = {\n  assets?: string[],\n  commands?: {[name: string]: string},\n  params?: InquirerPromptT[],\n  android: AndroidConfigParamsT,\n  ios: IOSConfigParamsT,\n};\n\nexport type InquirerPromptT = any;\n\nexport type AndroidConfigParamsT = {};\n```\n\n这与文档上的说明是一致的。\n\n## 第三方模块结构\n\n在我们深入 link.js 代码之前，我们先来看下一个包含 Native Modules 的第三方库的结构。\n\n第一个包含 Native Modules 的第三方库包含以下几个部分：\n\n- Android 原生代码：Android 平台的 Native Modules\n- iOS 原生代码：iOS 平台的 Native Modules\n- js 代码：对不同平台的 Native Modules 进行统一封装\n\n需要注意的是，这种 React Native 第三方库使用 npm 进行分发，因此位于工程的 `node_modules` 目录下。\n\n这对于习惯原生开发的同学来说是一个不同的地方。\n\n下面我们以 react-native-intent-launcher 这个第三方库为例，它位于 node_modules/react-native-intent-launcher 下。目录结构如下：\n\n```\nnode_modules/react-native-intent-launcher\n├── IntentConstant.js\n├── LICENSE\n├── README.md\n├── android\n│   ├── android.iml\n│   ├── build\n│   ├── build.gradle\n│   ├── gradle\n│   ├── gradlew\n│   ├── gradlew.bat\n│   ├── local.properties\n│   └── src\n├── index.js\n└── package.json\n```\n\n从中可以看出：\n\n- 它是一个前端工程，有 `package.json` 文件\n- android 目录是 Android 的 Native Modules，它被封装为一个 Android Module 工程\n- 因为这个项目是对 Android Intent 特性的封装，因此只有 Android 平台，没有 iOS 平台\n- 其中 android 目录是需要被 link 进主工程的 android 目录下的\n\n浏览这个项目后发现：\n\n- package.json：是一个普通的前端工程，没有特别的与 link 相关的信息，里面有一个 main 字段，指向 index.js\n- index.js：它是前面提到的 js 代码入口，提供 JS 侧的 Native Module 接口\n- android/build.gradle：一个普通的 Android Library Modules，其中对 React Native 的依赖没有指定固定的版本号\n- 题外话：不太好的一点是发现它依赖了 appcompat-v7:23.0.1，这个依赖是多余的，最好去掉\n\n通过对这个工程的分析，我们发现它并没有对 link 进行特殊的配置。\n\n因此，解析工程、找出 Native Modules 的任务都落在 link 命令里面了。\n\n有了这些背景知识，下面我们进入 link 内部一探究竟。\n\n## Android Platform 工具集\n\n在本文中，我们的核心问题是在 Android 中，引入 Native 需要修改 Gradle、Java 代码，这是如何实现的呢？\n\n这个问题的答案就在 packages/cli/src/commands/link/android 这个目录下。\n\n它提供了一系列函数，用于注册原生模块、解注册原生模块、拷贝资源等待。\n\n下面我们逐个来看：\n\n### 注册原生模块\n\n这个操作位于 packages/cli/src/commands/link/android/registerNativeModule.js 中：它的代码如下：\n\n```js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport applyPatch from './patches/applyPatch';\nimport makeStringsPatch from './patches/makeStringsPatch';\nimport makeSettingsPatch from './patches/makeSettingsPatch';\nimport makeBuildPatch from './patches/makeBuildPatch';\nimport makeImportPatch from './patches/makeImportPatch';\nimport makePackagePatch from './patches/makePackagePatch';\n\nexport default function registerNativeAndroidModule(\n  name,\n  androidConfig,\n  params,\n  projectConfig,\n) {\n  // 生成导入 Java 依赖的 patch\n  const buildPatch = makeBuildPatch(name);\n\n  // applyPatch 进行正则替换\n  // 在 settings.gradle 中通过相对路径导入 node_modules 下的库的 android 目录\n  applyPatch(\n    projectConfig.settingsGradlePath,\n    makeSettingsPatch(name, androidConfig, projectConfig),\n  );\n\n  // 在 app/build.gradle 下加入 Java Module 依赖\n  applyPatch(projectConfig.buildGradlePath, buildPatch);\n  // 向 strings.xml 中追加 string 资源\n  applyPatch(projectConfig.stringsPath, makeStringsPatch(params, name));\n\n  // 向注册 MainReactPackage 的地方插入第三方库的 Module\n  applyPatch(\n    projectConfig.mainFilePath,\n    makePackagePatch(androidConfig.packageInstance, params, name),\n  );\n\n  // 向注册 MainReactPackage 的地方加上 Java 类的 import\n  applyPatch(\n    projectConfig.mainFilePath,\n    makeImportPatch(androidConfig.packageImportPath),\n  );\n}\n\n```\n\n至此我们可以看出：\n\n- 核心原理是通过正则匹配进行内容替换\n- 即通过 Patch 的方法，在 Andorid 工程的各处打补丁\n\n### 感悟\n\nlink 中最神秘的部分被揭开了，感觉没有想象中那么美丽……没想到是靠暴力正则替换打 patch 实现的，有些失望。但是它确实能工作，而且也工作地很稳定。\n\n可能是 link 这个命令过于神奇(自动插入 gradle 依赖、自动插入 Java 代码)，因此期望过大。也确实，这么一个神奇的功能总不能是通过人工智能来实现的吧 2333\n\n这件事情给我的感悟是：\n\n- 基础的技术同样能做出很美妙的事情\n- 一个可靠运行的、实现不怎么高超的厉害功能远胜于一个实现高超但却跑不起来的功能\n- 有好点子的时候直奔目标而去，用直接的方法实现它，这就是最好的方法\n\n这不就是 KISS 思想吗？！通过这次代码分析加深了我的认识。\n\n### 资源拷贝\n\n资源拷贝就要简单多了 packages/cli/src/commands/link/android/copyAssets.js：\n\n```js\n/**\n * Copies each file from an array of assets provided to targetPath directory\n *\n * For now, the only types of files that are handled are:\n * - Fonts (otf, ttf) - copied to targetPath/fonts under original name\n */\nexport default function copyAssetsAndroid(\n  files: Array<string>,\n  project: {assetsPath: string},\n) {\n  const assets = groupFilesByType(files);\n\n  logger.debug(`Assets path: ${project.assetsPath}`);\n  (assets.font || []).forEach(asset => {\n    const fontsDir = path.join(project.assetsPath, 'fonts');\n    logger.debug(`Copying asset ${asset}`);\n    // @todo: replace with fs.mkdirSync(path, {recursive}) + fs.copyFileSync\n    // and get rid of fs-extra once we move to Node 10\n    fs.copySync(asset, path.join(fontsDir, path.basename(asset)));\n  });\n}\n```\n\n从中可以看出，它现在只支持对字体资源的拷贝。\n\n## link 命令\n\n### 入口\n\nlink 命令的入口在 packages/cli/src/commands/link/link.js。\n\n我们先来看这个入口对外导出了什么：\n\n```js\nexport default {\n  func: link,\n  description: 'scope link command to certain platforms (comma-separated)',\n  name: 'link [packageName]',\n  options: [\n    {\n      command: '--platforms [list]',\n      description:\n        'If you want to link dependencies only for specific platforms',\n      parse: (val: string) => val.toLowerCase().split(','),\n    },\n  ],\n};\n```\n\n其中：\n\n- 包含有这个命令的使用说明\n- 负责干活的函数是 link\n\n下面我们就来详细看 link 函数。\n\n\n### link 函数\n\nlink 函数的签名如下：\n\n```js\n/**\n * Updates project and links all dependencies to it.\n *\n * @param args If optional argument [packageName] is provided,\n *             only that package is processed.\n */\nfunction link([rawPackageName]: Array<string>, ctx: ContextT, opts: FlagsType) {\n```\n\n其中：\n\n- rawPackageName 需要连接的模块名称，可以不填\n\n- opts 配置选项\n\n它将 link 操作拆分为以下几个步骤：\n\n1. 模块解析\n2. prelink\n3. linkDependency\n4. postlink\n5. linkAssets\n\n原来还有资源文件也会一同链接进入主工程。\n\n我们在前面已经分析过了模块解析，以及 Android Platform 工具集中的核心操作。\n\nlink 命令在这里只是进行了目录解析，和将这些过程串联起来，这些都是非核心的工作，因此不再赘述。\n\n## 结论\n\n在本文中，我们以 react-native link 命令为起点，通过深入挖掘，了解到原来 React Native 中还有 React Native Package Manager 项目，同时也分析了 react-native link 的实现原理，打开了它的神秘面纱。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"path":"post/ReactNativeCode11md"}
