{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（六）：C++ 侧的 Instance 类","desc":"Instance 是 React Native 在 C++ 侧非常重要的一个类。初始化 Bridge、加载 Bundle 都通过它完成。在本文中，我们先来分析它在整个 React Native 框架中的位置。","type":"md","link":"ReactNativeCode6md","create":"2019-02-19","filename":"ReactNativeCode6.md"},"content":"## 前言\n\nInstance 是 React Native 在 C++ 侧非常重要的一个类。初始化 Bridge、加载 Bundle 都通过它完成。在本文中，我们先来分析它在整个 React Native 框架中的位置。\n\n## 实例创建\n\nInstance 实例是何时创建的呢？\n\nInstance 是 CatalystInstanceImpl 的成员 `instance_` ，在 CatalystInstanceImpl 的构造函数中一同创建。\n\nInstance 创建实例后，需要外界调用它的 initializeBridge 方法来初始化。这一步位于 CatalystInstanceImpl::initializeBridge 中。\n\n我们来看 Instance::initializeBridge 方法，CatalystInstanceImpl::initializeBridge 外部调用代码为：\n\n```java\ninstance_->initializeBridge(\n    folly::make_unique<JInstanceCallback>(\n        callback,\n        moduleMessageQueue_),\n    jseh->getExecutorFactory(),\n    folly::make_unique<JMessageQueueThread>(jsQueue),\n    moduleRegistry_);\n```\n\n在 Instance::initializeBridge 的方法签名：\n\n```java\nvoid Instance::initializeBridge(\n    std::unique_ptr<InstanceCallback> callback,\n    std::shared_ptr<JSExecutorFactory> jsef,\n    std::shared_ptr<MessageQueueThread> jsQueue,\n    std::shared_ptr<ModuleRegistry> moduleRegistry) {\n```\n\n我们可以对照来看。其内部逻辑是：\n\n首先存下 callback 和 moduleRegistry：\n\n```java\ncallback_ = std::move(callback);\nmoduleRegistry_ = std::move(moduleRegistry);\n```\n\n之后向 jsQueue 上扔了一个闭包：\n\n```java\njsQueue->runOnQueueSync([this, &jsef, jsQueue]() mutable {\n    nativeToJsBridge_ = folly::make_unique<NativeToJsBridge>(\n        jsef.get(), moduleRegistry_, jsQueue, callback_);\n\n    std::lock_guard<std::mutex> lock(m_syncMutex);\n    m_syncReady = true;\n    m_syncCV.notify_all();\n});\n```\n\n其中，主要操作是存下 `nativeToJsBridge_` 。\n\n这样即完成了初始化操作。\n\n## NativeToJsBridge\n\n### 介绍\n\n上文中的 NativeToJsBridge 是什么呢？\n\n它位于 ReactCommon/cxxreact/NativeToJsBridge.h，注解为：\n\n这个类管理从 Native 代码到 JS 的调用。他还管理执行器和他们的线程。这里所有的方法都可以在任意线程中调用。\n\n除了 loadApplicationScriptSync 之外，所有的 void 方法都要扔到 jsQueue 上运行，并立刻返回。\n\n### 执行器（Executor）\n\n在注释中提到了执行器，我们快速回顾一下 Executor 是什么。它对应的类是 JSExecutor，这个类是一个基类，它的作用是隔离各种运行时（其实总共就一种）。\n\n基于它派生出 JSCExecutor，它是 JavaScriptCore 的封装层，也就是 JS 引擎了。\n\n我们再来看 NativeToJsBridge 的构造函数：\n\n```java\nNativeToJsBridge::NativeToJsBridge(\n    JSExecutorFactory* jsExecutorFactory,\n    std::shared_ptr<ModuleRegistry> registry,\n    std::shared_ptr<MessageQueueThread> jsQueue,\n    std::shared_ptr<InstanceCallback> callback)\n    : m_destroyed(std::make_shared<bool>(false))\n    , m_delegate(std::make_shared<JsToNativeBridge>(registry, callback))\n    , m_executor(jsExecutorFactory->createJSExecutor(m_delegate, jsQueue))\n    , m_executorMessageQueueThread(std::move(jsQueue)) {}\n```\n\n其中 `m_executor` 这行我们可以看出，NativeToJsBridge 从 Holder 中自己创建了一个 JS 运行时。\n\nNativeToJsBridge 中各种方法则是基于运行时封装出的能力。\n\n## 回到 Instance\n\nNativeToJsBridge 弄清楚后，我们回到 Instance。\n\nInstance 将 NativeToJsBridge 实例存放在 `nativeToJsBridge_` 成员中。\n\nInstance 基于 NativeToJsBridge 提供的 JS 运行时，提供了一下能力：\n\n-   loadApplication 执行 JS 应用代码\n-   loadApplicationSync 同步执行 JS 应用代码\n-   setSourceURL 设置 sourceURL\n-   loadScriptFromString 根据 string 执行 JS 代码\n-   loadRAMBundleFromFile 加载 RAMBundle 代码\n-   callJSFunction 调用 JS 方法\n-   registerBundle 注册 Bundle\n\n## CatalystInstanceImpl 对 Instance 的使用\n\nInstance 作为 CatalystInstanceImpl 的成员，CatalystInstanceImpl 是如何使用它的呢？\n\nCatalystInstanceImpl::extendNativeModules：\n\n-   实际调用 `moduleRegistry_->registerModules`\n\nCatalystInstanceImpl::jniSetSourceURL：\n\n-   实际调用 `instance_->setSourceURL(sourceURL);`\n\nCatalystInstanceImpl::jniRegisterSegment：\n\n-   实际调用 `instance_->registerBundle`\n\nCatalystInstanceImpl::jniLoadScriptFromAssets：\n\n-   实际调用 `instance_->loadRAMBundle`\n\n在这里省略一些方法。因为已经足够看出，CatalystInstanceImpl 中大部分方法都是加载 JS bundle，与运行时打交道，而这些与运行时相关的具体操作，都代理封装在了 Instance 中。\n\n## CatalystInstanceImpl::getInstance()\n\n在 CatalystInstanceImpl 中还有一个方法，即 CatalystInstanceImpl::getInstance()，外界可以通过它获取 Instance 实例。在外部都有哪些类使用到它呢？\n\n找了一圈，原来并没有调用的地方。\n\n## 小结\n\n至此我们可以得出 Instance 类的作用是做什么的了：\n\n-   它是 CatalystInstanceImpl 与 JavaScriptCore 之间的中间层\n-   它向下封装了一些列 JavaScript 运行时 API，向上提供给 CatalystInstanceImpl\n-   CatalystInstanceImpl 通过代理模式获得了 Instance 的能力，对外提供这组 API\n\n"},"path":"post/ReactNativeCode6md"}
