{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（七）：CatalystInstanceImpl 的创建","desc":"CatalystInstanceImpl 是 React Native 中很重要的一个类。因为它横跨 Java、C++ 两侧（这在 React Native 中称为 Hybrid），所以它的创建过程有点复杂。在本文中我们一探它的创建过程。","type":"md","link":"ReactNativeCode7md","create":"2019-02-19","filename":"ReactNativeCode7.md"},"content":"## 前言\n\nCatalystInstanceImpl 是 React Native 中很重要的一个类。因为它横跨 Java、C++ 两侧（这在 React Native 中称为 Hybrid），所以它的创建过程有点复杂。在本文中我们一探它的创建过程。\n\n## Java 层实例创建\n\n我们先从 Java 层下手。还记得 CatalystInstanceImpl 是通过 Builder 模式构造的吗？\n\n在整个 React Native 中只有一个地方会创建这个 Builder，即在 ReactInstanceManager 的 createReactContext 方法中。具体创建流程在之前的系列中已有讲解这里不再赘述。\n\n在这里我们再向前进一步，ReactInstanceManager 是在哪里创建的呢？还记得在 React Native 官方文档中，如何在 Android 项目中集成 React Native 吗？\n\n示例代码如下：\n\n```java\npublic class MainActivity extends Activity implements DefaultHardwareBackBtnHandler {\n\n    private ReactInstanceManager mReactInstanceManager;\n    private ReactRootView mReactRootView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mReactRootView = new ReactRootView(this);\n\n        mReactInstanceManager = ReactInstanceManager.builder()\n                .setApplication(getApplication())\n                .setBundleAssetName(\"index.android.bundle\")\n                .setJSMainModuleName(\"index.android\")\n                .addPackage(new MainReactPackage())\n                .setUseDeveloperSupport(BuildConfig.DEBUG)\n                .setInitialLifecycleState(LifecycleState.RESUMED)\n                .build();\n\n        mReactRootView.startReactApplication(mReactInstanceManager, \"Basic\", null);\n\n        setContentView(mReactRootView);\n    }\n```\n\n我们可以看出，一个包含 ReactRootView 的 Activity 中，只会有一个 ReactInstanceManager 实例，进而只会有一个 CatalystInstanceImpl 实例。\n\n## C++ 层实例的创建\n\n### 卖个关子\n\n在这里我先卖个关子。CatalystInstanceImpl 在 C++ 侧对应的类是 ReactAndroid/src/main/jni/react/jni/CatalystInstanceImpl.h。\n\n我们可以在 React Native 的 C++ 代码中搜索，看看哪里有创建这个实例的地方？\n\n我们会发现，就算把代码都找遍了，也找不到。\n\n奇怪了吧？这里就要说到 React Native 底层的一个 Native 依赖库，叫 fbjni，它包含一个框架，通过这个框架，我们能在 C++ 侧建立一个与 Java 侧为映射关系的类。相当于提供了一种机制，对 JVM 中的类建立一个 C++ 侧的映像。\n\n在本文中，我们不展开讲 fbjni 的实现原理（涉及篇幅太长，等我梳理好后会放在后面的文章中），而是把它当做一个黑盒，主要精力放在这个问题：\n\n-   CatalystInstanceImpl 的 Java 对象的创建我们已经明白了\n-   C++ 侧对象是在哪创建的？怎么创建的？\n\n### CatalystInstanceImpl 类\n\n我们先来看 CatalystInstanceImpl 类的继承关系：\n\n```c++\nclass CatalystInstanceImpl : public jni::HybridClass<CatalystInstanceImpl> {\n public:\n  static constexpr auto kJavaDescriptor = \"Lcom/facebook/react/bridge/CatalystInstanceImpl;\";\n\n  static jni::local_ref<jhybriddata> initHybrid(jni::alias_ref<jclass>);\n  ~CatalystInstanceImpl() override;\n```\n\n其中：\n\nHybridClass 位于 ReactAndroid/src/main/jni/first-party/fb/include/fb/fbjni/Hybrid.h。这是 fbjni 中的类。\n\n在这里我们把 fbjni 当做黑盒，先速成一下 fbjni 的使用。\n\n### HybridClass 速成\n\n假设我们在 Java 侧有一个类叫 Foo（它的完整类名是 com.maxiee.Foo），我们想要创建一个它在 C++ 侧的映射类。\n\n因此我们声明这样一个 C++ 类：\n\n```c++\nclass Foo : public jni::HybridClass<Foo> {\npublic:\n    static constexpr auto kJavaDescriptor = \"Lcom/maxiee/Foo\";\n\n    static jni::local_ref<jhybriddata> initHybrid(jni::alias_ref<jclass>);\n\n    static void registerNatives();\n}\n```\n\n其中：\n\n-   kJavaDescriptor 是 fbjni 中的命名约定，用于指明对应的 Java 类\n-   initHybrid 是一个静态方法，它是供 Java 侧调用的，C++ 实例就是在这个方法里创建出来的\n-   说到 Java 侧调用 initHybrid，就不得不提到（别开花！）JNI，因此 registerNatives 方法是注册 JNI 用的\n\n下面先看 initHybrid 实现：\n\n```c++\njni::local_ref<Foo::jhybriddata> Foo::initHybrid(jni::alias_ref<jclass>) {\n    return makeCxxInstance();\n}\n```\n\n其中：\n\n-   这个方法看起来很吓人，打眼一看像是这样 `::::::<><>::::::><><:::::><>><><` 跟象形文字一样\n-   其实它很简单，简单说就是通过 makeCxxInstance 方法，创建一个与 Java 侧对象关联的对象\n\n这个对象是返回到 Java 层的，我们看下 Java 层的实现：\n\n```c++\npublic class Foo {\n    static {\n        SoLoader.loadLibrary(\"my-lib-contains-foo\");\n    }\n\n    // C++ parts\n    private final HybridData mHybridData;\n    private native static HybridData initHybrid();\n\n    public Foo() {\n        mHybridData = initHybrid();\n    }\n\n    public destroy() {\n        mHybridData.resetNative();\n    }\n}\n```\n\n其中：\n\n-   首先我们要先装载 So 库\n-   mHybridData 用于存放 C++ 侧实例\n-   在构造函数中我们创建 C++ 实例\n-   我们提供了一个 destroy 方法，用于销毁 C++ 实例\n\n最后再看 registerNatives 方法，它用于在 Native 库 OnLoad 时注册 JNI 方法：\n\n```c++\nregisterHybrid({\n    makeNativeMethod(\"initHybrid\", Foo::initHybrid)\n});\n```\n\n其中：\n\n-   registerHybrid 和 makeNativeMethod 也是 React Native 中提供的注册方法\n\n## 小结\n\n至此我们对 CatalystInstanceImpl 的 Java 侧和 C++ 侧两头怎么创建的都明了了。\n\n我们也开始接触到 fbjni 这个库，这个库很有意思，也不容易掌握。希望我未来能够写一篇详解它的文章。\n\n"},"path":"post/ReactNativeCode7md"}
