{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native 代码阅读（三）：给 Java 对象添加析构机制（Android）","desc":"React Native 代码阅读系列第三篇，在学习 React Native 代码的时候，我发现他实现了一种机制，给 Java 对象添加了析构函数的机制。在本文中我们一探究竟。","type":"md","link":"ReactNativeCode3md","create":"2019-02-01","filename":"ReactNativeCode3.md"},"content":"## 介绍\n\n我们知道在 Java 中是没有析构函数这个机制的。在学习 React Native 代码的时候，我发现他实现了一种机制，给 Java 对象添加了析构函数的机制。\n\n在本文中我们一探究竟。\n\n## DestructorThread\n\n### 介绍\n\n我们从 DestructorThread 入手，它内部包含一条线程，他会在对象被垃圾回收时执行一个析构的机制。这是给 Java 对象添加了一个析构方法。\n\n从中我们可以理解：我们启动一条线程，它监听 JVM 的垃圾回收过程，hook 住对象被回收的时机，并在对象被回收前触发回调，这个回调就是对象的析构函数。\n\n### DestructorThread.Destructor\n\nDestructor 是对象的析构器，它内部含有析构函数。需要析构特性的对象，需要创建一个 DestructorThread.Destructor 的静态子类，一旦引用对象被垃圾回收，DestructorThread 就会调用到 Destructor#destruct() 方法。\n\n它的实现如下：\n\n```java\npublic abstract static class Destructor extends PhantomReference<Object> {\n\n    private Destructor next;\n    private Destructor previous;\n\n    Destructor(Object referent) {\n        super(referent, sReferenceQueue);\n        sDestructorStack.push(this);\n    }\n\n    private Destructor() {\n        super(null, sReferenceQueue);\n    }\n\n    /** Callback which is invoked when the original object has been garbage collected. */\n    abstract void destruct();\n}\n```\n\n前面我们说到，监听 JVM 的垃圾回收过程，hook 住对象被回收的时机，这是怎么实现的呢？答案就在这里，我们使用了 PhantomReference（虚引用）。虚引用是 Java 对象引用方式的一种，由于平时较少用到所以很多人可能不太了解，它的作用就是给一个对象释放的 hook 时机。需要注意的是，它必须要同 ReferenceQueue 一起使用。\n\n其中：\n\n-   在构造函数中传入 sReferenceQueue，这是 ReferenceQueue 实例，在下一节中会介绍。\n-   同时还会向 sDestructorStack 中入栈自己，在下一节中会介绍。\n-   同时还有一个 destruct 抽象方法，这个就是析构函数。\n\n除此之外，我们还注意到 Destructor 自身是一个链表结构，它持有前后对象的引用。\n\n### 静态区\n\n我们来看 DestructorThread 的静态区：\n\n```java\nstatic {\n    sDestructorStack = new DestructorStack();\n    sReferenceQueue = new ReferenceQueue();\n    sDestructorList = new DestructorList();\n    sThread = new Thread(\"HybridData DestructorThread\") {\n        @Override\n        public void run() {\n        while (true) {\n            try {\n            Destructor current = (Destructor) sReferenceQueue.remove();\n            current.destruct();\n\n            if (current.previous == null) {\n                sDestructorStack.transferAllToList();\n            }\n\n            DestructorList.drop(current);\n            } catch (InterruptedException e) {}\n        }\n        }\n    };\n\n    sThread.start();\n}\n```\n\n这里初始化了几个成员，他们的类型分别为：\n\n```java\nprivate static DestructorList sDestructorList;\nprivate static DestructorStack sDestructorStack;\nprivate static ReferenceQueue sReferenceQueue;\nprivate static Thread sThread;\n```\n\n下面我们来分析这个过程。\n\n### ReferenceQueue\n\nReferenceQueue 是一种特殊的队列，称为引用队列。\n\n它的使用方法是这样的：\n\n```java\nReferenceQueue sReferenceQueue = new ReferenceQueue()\n\n// ...\n\nwhile(true) {\n    try {\n        Object o = sReferenceQueue.remove();\n    } catch (InterruptedException e) {}\n}\n```\n\n其中：\n\n-   前面我们在建立虚引用的时候传入了 sReferenceQueue，这些虚引用会放入 ReferenceQueue 中进行跟踪\n-   这个 remove 方法是阻塞式的，直到有对象被内存回收时才会吐出对象来\n-   由于这个过程是阻塞式的，因此要单独放到一个线程中去，这也是 DestructorThread 内部包含一个线程的原因\n\n### DestructorStack\n\n我们来看 DestructorStack 的实现：\n\n```java\n/** This is a thread safe, lock-free Treiber-like Stack of Destructors. */\nprivate static class DestructorStack {\n    private AtomicReference<Destructor> mHead = new AtomicReference<>();\n\n    public void push(Destructor newHead) {\n        Destructor oldHead;\n        do {\n        oldHead = mHead.get();\n        newHead.next = oldHead;\n        } while (!mHead.compareAndSet(oldHead, newHead));\n    }\n\n    public void transferAllToList() {\n        Destructor current = mHead.getAndSet(null);\n        while (current != null) {\n            Destructor next = current.next;\n            sDestructorList.enqueue(current);\n            current = next;\n        }\n    }\n}\n```\n\n其中：\n\n-   这里实现了一个并发栈，具体参考 [Treiber stack](https://en.wikipedia.org/wiki/Treiber_stack)。\n-   其中 mHead 指向栈顶，每次 Push 都修改内部 next 指向\n-   transferAllToList 的作用是将栈中数据都存入 sDestructorList 中\n\n### DestructorList\n\nDestructorList 的作用是持有所有内存中活跃的析构器（析构函数是以类实例的形式存在的）。\n\n它是一个静态类，我们看下它的实现：\n\n```java\n/** A doubly-linked list of Destructors. */\nprivate static class DestructorList {\n    private Destructor mHead;\n\n    public DestructorList() {\n        mHead = new Terminus();\n        mHead.next = new Terminus();\n        mHead.next.previous = mHead;\n    }\n\n    public void enqueue(Destructor current) {\n        current.next = mHead.next;\n        mHead.next = current;\n\n        current.next.previous = current;\n        current.previous = mHead;\n    }\n\n    private static void drop(Destructor current) {\n        current.next.previous = current.previous;\n        current.previous.next = current.next;\n    }\n}\n```\n\n其中，Terminus 是析构器的一个默认实现：\n\n```java\nprivate static class Terminus extends Destructor {\n    @Override\n    void destruct() {\n        throw new IllegalStateException(\"Cannot destroy Terminus Destructor.\");\n    }\n}\n```\n\n这个类执行了入队和出队操作。\n\n### 工作原理\n\n前面我们将各个部分分别进行了学习，在本节中结合起来分析。\n\n在 Destructor 构造的时候，DestructorThread 的静态区会被执行，DestructorList、DestructorStack、ReferenceQueue 和线程都被初始化。\n\n在 Destructor 的构造函数中：\n\n```java\nprivate Destructor() {\n    super(null, sReferenceQueue);\n    sDestructorStack.push(this);\n}\n```\n\n会建立虚引用，并绑定到 sReferenceQueue 中。\n\n同时会向栈中入栈，我们来看第一次入栈时的 DestructorStack.push 的情景：\n\n-   对象的 next 指向 oldHead（此时是空的）\n-   mHead 指向我们的新对象\n-   此时对象的 mPrevious 还是空的\n\n这样如果对象被释放，我们起的线程会有反应：\n\n```java\nsThread = new Thread(\"HybridData DestructorThread\") {\n    @Override\n    public void run() {\n    while (true) {\n        try {\n        Destructor current = (Destructor) sReferenceQueue.remove();\n        current.destruct();\n\n        if (current.previous == null) {\n            sDestructorStack.transferAllToList();\n        }\n\n        DestructorList.drop(current);\n        } catch (InterruptedException e) {\n        // Continue. This thread should never be terminated.\n        }\n    }\n    }\n};\n```\n\n其中：\n\n-   首先会调用 current 的析构函数\n-   之后会将栈中的内容都转到列表中\n-   再从列表中丢掉当前对象\n\n## 外部使用\n\n### 介绍\n\n在上一节中我们分析了 DestructorThread 内部的工作原理。在本节中我们来看是如何使用这个析构机制的。\n\n在 React Native 中，使用到这个机制的类是 HybridData 类。我们看下它的实现：\n\n```java\npublic class HybridData {\n\n  static {\n    SoLoader.loadLibrary(\"fb\");\n  }\n\n  private Destructor mDestructor = new Destructor(this);\n\n  public synchronized void resetNative() {\n    mDestructor.destruct();\n  }\n\n  public boolean isValid() {\n    return mDestructor.mNativePointer != 0;\n  }\n\n  public static class Destructor extends DestructorThread.Destructor {\n\n    private long mNativePointer;\n\n    Destructor(Object referent) {\n      super(referent);\n    }\n\n    @Override\n    void destruct() {\n      deleteNative(mNativePointer);\n      mNativePointer = 0;\n    }\n\n    static native void deleteNative(long pointer);\n  }\n}\n```\n\n其中：\n\n-   在创建 HybridData 实例时，创建 mDestructor 成员，并将自己传入 Destructor。\n-   这样在 Destructor 中建立了对 HybridData 的虚引用\n-   当外界没有对 HybridData 实例的引用后，GC 会将其回收，此时会触发我们 DestructorThread 中的线程\n-   我们从 ReferenceQueue remove 得到虚引用的对象（Destructor），并执行它的 destruct 方法，这个方法在基类中是一个抽象方法，HybridData.destruct 实现了这个方法\n-   HybridData.destruct 具体的逻辑是：调用 Native 侧的 deleteNative 可以推导出是删除 Native 侧的对象，之后清空 native 侧的指针\n-   这些都完成后 HybridData 就被彻底从 JVM 中回收了\n\n### HybridData\n\nHybridData 这个类在 ReactNative 中广泛被使用，它是一种特殊的对象，虽然它是一个 Java 对象，但它同时引用这一个 Native 对象，并且在 Java 对象回收的时候，Native 也同时回收。\n\n### CatalystInstanceImpl 中的 HybridData\n\n1. 介绍\n\n    下面我们来看，在 CatalystInstanceImpl 中是如何使用 HybridData 的。\n\n    在 CatalystInstanceImpl 中有两个成员：\n\n    ```java\n    private final HybridData mHybridData;\n    private native static HybridData initHybrid();\n    ```\n\n    在构造函数中：\n\n    ```java\n    mHybridData = initHybrid();\n    ```\n\n    我们可以看出，在构函数中，CatalystInstanceImpl 调用了原生的 initHybrid 方法，并将返回值存入 mHybridData。\n\n    下面我们进入 Native 层，看看 initHybrid 的实现。\n\n2. Native 层 initHybrid\n\n    在 ReactAndroid/src/main/jni/react/jni/CatalystInstanceImpl.cpp 的 CatalystInstanceImpl::initHybrid，对应实现为：\n\n    ```c++\n    jni::local_ref<CatalystInstanceImpl::jhybriddata> CatalystInstanceImpl::initHybrid(\n        jni::alias_ref<jclass>) {\n      return makeCxxInstance();\n    }\n    ```\n\n    其中 makeCxxInstance 定义在 ReactAndroid/src/main/jni/first-party/fb/include/fb/fbjni/Hybrid.h 中：\n\n    ```c++\n    template<typename T>\n    local_ref<HybridDestructor> getHolder(T t) {\n      static auto holderField = t->getClass()->template getField<HybridDestructor::javaobject>(\"mDestructor\");\n      return t->getFieldValue(holderField);\n    }\n    \n    template<typename T>\n    void setNativePointer(T t, std::unique_ptr<detail::BaseHybridClass> new_value) {\n      getHolder(t)->setNativePointer(std::move(new_value));\n    }\n    \n    static local_ref<detail::HybridData> makeHybridData(std::unique_ptr<T> cxxPart) {\n      auto hybridData = detail::HybridData::create();\n      setNativePointer(hybridData, std::move(cxxPart));\n      return hybridData;\n    }\n    \n    template <typename... Args>\n    static local_ref<detail::HybridData> makeCxxInstance(Args&&... args) {\n      return makeHybridData(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n    }\n    ```\n\n    这段 C++ 代码看起来想当费劲，大体可以知道：\n\n    -   Java 层 makeCxxInstance(); 时并没有传入参数，因此 args 是空的\n    -   在 CatalystInstanceImpl 中 initHybrid 是一个静态方法\n    -   通过我强大的脑补能力，我觉得这里是创建了一个 Native 层 CatalystInstanceImpl 的实例，同时被 Wrap 成一个 HybridData 对象，用于 Java 层使用\n    -   这样的好处是，Native 层 CatalystInstanceImpl 就像一个 Java 对象，在没有引用后也可以被自动回收\n\n## 结论\n\n在本文中，我们分析了 React Native 中，给 Java 添加析构机制，其实质是使用了 Java 的虚引用特性。\n\n同时我们也分析了 React Native 中使用这一机制的 HybridData 类，并用 CatalystInstanceImpl 为例，分析了它的实际用法。\n\n"},"path":"post/ReactNativeCode3md"}
