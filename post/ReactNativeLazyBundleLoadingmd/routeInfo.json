{"template":"/home/maxiee/Code/Blog/maxiee.github.io/src/pages/post","sharedHashesByProp":{},"data":{"post":{"name":"React Native Bundle 懒加载(翻译)","desc":"在本文中将实现 React Native 的 Bundle 懒加载技术，会深入 Metro 和 React Native iOS 代码库的内部实现。这篇关于懒加载的文章写得非常好，强烈推荐！","type":"md","link":"ReactNativeLazyBundleLoadingmd","create":"2019-04-03","filename":"ReactNativeLazyBundleLoading.md"},"content":"## 前言\n\n本文的原作者是 [Karan Thakkar](https://medium.com/@karanjthakkar)，文章源链接 [Lazy Bundle Loading in React Native 🔥](https://medium.com/react-native-training/lazy-bundle-loading-in-react-native-5f717b65482a)，我将其翻译成中文。\n\n在本文中将实现 React Native 的 Bundle 懒加载技术，会深入 Metro 和 React Native iOS 代码库的内部实现。\n\n包懒加载技术主要包含以下几个难点：\n\n- 如何根据屏幕进行 React Native Bundle 切分\n- 跟踪代码执行过程，找出 [JavascriptCore](https://facebook.github.io/react-native/docs/javascript-environment) 中加载执行 Bundle 的代码，将它复制出来\n- 拦截 React Native 实现懒加载，在跳转到这个页面的时候再加载 JavaScript Bundle\n\n## 使用 Metro 进行 Code Splitting\n\nMetro 本身没有自带像 Webpack 的 [CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/) 那样的通过动态 import 的包切分机制。\n\n有一个叫 [Haul](https://github.com/callstack/haul) 基于 Webpack 的 React Native 打包器能做这个事情，但是在本文中我们不打算切换打包器，而是仍使用 Metro。\n\n在本文中，我们编写两个很简单的屏幕界面，先试图手动切分 Bundle。\n\n项目的入口文件是 index.js，我创建了两个版本：\n\n1. 版本一：Bundle 中只有屏幕 A\n\n2. 版本二：Bundle 中有屏幕 A 和屏幕 B\n\n这样，我们通过手动 diff 最终的 bundle，就能得到屏幕 B 的代码。\n\n我们先来看两个版本的代码：\n\n版本一：\n\n![](image/ReactNativeLazyBundleLoading01.png)\n\n版本二：\n\n![](image/ReactNativeLazyBundleLoading02.png)\n\n我试用这两个版本的入口文件通过下面的打包命令分别打出两个 Bundle 来：\n\n```\nreact-native bundle \\\n        --platform ios \\\n        --entry-file index.js \\\n        --bundle-output ./ios/main.jsbundle\n```\n\n下面我使用功能 diff 工具(如 [DiffMerge](https://sourcegear.com/diffmerge/)) 对两个 Bundle 进行 diff 比较，会得出许多差异。\n\n我们从上向下一块一块来看，首先是第一块：\n\n![](image/ReactNativeLazyBundleLoading03.png)\n\n其中：\n\n- 左边是只有屏幕 A\n- 右边是有屏幕 A 和屏幕 B\n\n- 右图中红色部分是屏幕 B 所多出的部分\n\n- index.js 经过打包后就会变成这样。\n\n在上面的 Diff 中，主要包含三个不同之处。\n\n- 第一个不同是额外的 ScreenB 导入。\n    - 注意 `_dependencyMap` 是这个函数收到的模块 ID 的数组。所以：\n        - `_dependencyMap[0] = react-native`\n        - `_dependencyMap[1] = ScreenA`\n        - `_dependencyMap[2] = ScreenB`\n- 第二个不同是调用 AppRegistry 来注册 ScreenB\n\n- 第三个不同是 Metro 给 ScreenB 模块指定的 ID 是 354，将这个 ID 传入方法\n\n每个 `__d(…)` 函数都表示你的 React Native 应用中的一个文件/模块。\n\n- 它的第二参数：在本例中为 0，表示 Metro 给我们的 index.js 的 id\n\n第二块 diff 如下：\n\n![](image/ReactNativeLazyBundleLoading04.png)\n\n这是 ScreenB.js 的代码，它在最终的 Bundle 中的模块 id 为 354。\n\n因此，如果要创建一个单独的 ScreenB 包，我们需要做两件事：\n\n**① 更新 main.jsbundle**\n\n- 删除 ScreenB 的 import 和 registration\n- 从传到 ` __d(…)` 的 dependency map  中删除 ScreenB 的模块 id，354\n- 删除编译后的 module 中删除 ScreenB.js 的代码(第二块 diff)\n\n![](image/ReactNativeLazyBundleLoading05.png)\n\n**② 将代码迁移到新文件——ScreenB.jsbundle**\n\n我创建了一个新的 ` __d(…)` 来进行模块注册。\n\n我需要创建一个唯一的模块 ID，我选择了 355，因为 354 是 main.jsbundle 中的最后一个模块 ID。\n\nScreenB 现在是 dependencyMap 数组中的第二个元素，而不是第三个，因此我将 `_dependencyMap[2]` 改为 `_dependencyMap[1]`。\n\n修改后的 ScreenB.jsbundle 中这一部分如下：\n\n![](image/ReactNativeLazyBundleLoading06.png)\n\n现在 ScreenB.jsbundle 几乎要完成了。它向 Metro 注册了两个模块，但是我们希望同时也消费它。\n\n这可以参考 main.jsbundle 来看消费是怎么回事：\n\n![](image/ReactNativeLazyBundleLoading07.png)\n\n在 main.jsbundle 中，真正的开始处是最后一行的 `require(0)`。\n\n它会触发应用来执行模块 id 为 0 的代码，即 React Native 的入口文件 index.js。\n\n由于我们把 ScreenB 的注册移动到一个单独的模块中，我们需要触发它执行，以使他注册到 React Native 中。\n\n因此我们在 ScreenB.jsbundle 的最后一行中加入句 `require(355)`。\n\n如下图所示：\n\n![](image/ReactNativeLazyBundleLoading08.png)\n\n现在我们的分割任务就完成了！🌟\n\n## 在 React Native 中懒加载并执行差分包\n\n每个 React Native APP 都是从创建 RCTBridge 实例开始的。\n\n其中，React Native 加载 JavaScript，要么从本地打包器(调试模式)，要么从预编译的 Bundle(发布模式)\n\n，并且在 JavaScriptCore 中进行执行：\n\n![](image/ReactNativeLazyBundleLoading09.png)\n\n当调用 initWithBundleURL 时，会按顺序发生以下事件：\n\n1. RCTBridge 实例被创建，并且 `_bundleURL` 被设为我们的传入值——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/Base/RCTBridge.m#L196)\n2. 对象的 setUp 方法被调用，它会初始化 RCTCxxBridge (即 batched bridge)——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/Base/RCTBridge.m#L316)\n\n3. batched bridge 的 start 方法被调用——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/Base/RCTBridge.m#L317)\n4. 这是 Bundle 真正被加载和执行的地方——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/CxxBridge/RCTCxxBridge.mm#L358)\n\n因此，在我们的自定义加载过程中，我们需要做两件事情：\n\n**① 设置 Bridge 来加载自定义 Bundle**\n\n我们需要将 `_bundleURL` 指向我们的差分包：ScreenB.jsbundle。\n\n因此我们需要在 RCTBridge.m 中创建一个自定义方法，并在 RCTBridge.h 中暴露它。\n\n如果我们想在用户业务代码中调到，只能这么干(改 React Native 的底层代码)。\n\n暴露接口如下：\n\n![](image/ReactNativeLazyBundleLoading10.png)\n\n代码实现如下：\n\n![](image/ReactNativeLazyBundleLoading11.png)\n\n先不用担心 loadCustomBundle 中的这个 lazyStart，我们会在下文中实现它。🙂\n\n**② 加载并执行新 Bundle**\n\n我们将 RCTCxxBridge.mm 的 start 方法中加载和执行 JavaScript 的逻辑复制一份到我们的 loadCustomBundle 新方法中。\n\n其中，start 方法中初始化了很多东西，它最终做了三件事：\n\n1. 初始化 bridge 对象以使得 Native 到 JS 的通信成为可能——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/CxxBridge/RCTCxxBridge.mm#L354)\n2. 根据 Bundle URL 加载 Bundle——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/CxxBridge/RCTCxxBridge.mm#L361)\n3. 由于上面这些步骤都是异步的，需要等待它们完成，者通过使用 [**dispatch_group_notify**](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/CxxBridge/RCTCxxBridge.mm#L376) ，当异步调用完成后它会被调用。然后，它会使用第一步创建的 bridge 执行加载的 JavaScript Bundle String——[Code](https://github.com/facebook/react-native/blob/3c6a916536da67a4591f71883723c67a0c7be9d7/React/CxxBridge/RCTCxxBridge.mm#L379)\n\n基于这些，我们的 lazyStart 如下所示：\n\n![](image/ReactNativeLazyBundleLoading12.png)\n\n其中，我们不需要初始化 bridge 对象，因为它已经在首次加载 Bundle 时完成了。\n\n在这里我们只需要做两件事：\n\n1. 通过 loadSource 加载新的 JavaScript Bundle。这会在内部使用我们在 loadCustomBundle 方法中设置的 bundleURL\n2. 一旦加载完毕，我们执行 JavaScript Bundle，因为我们没有多个异步调用，因此不需要使用 `dispatch_group_notify`\n\n下面我们需要暴露 RCTCxxBridge.mm 中的这个方法，使得在 RCTBridge.m 中也能调用 loadCustomBundle。\n\n我们通过修改 RCTBridge+Private.h 接口来实现：\n\n![](image/ReactNativeLazyBundleLoading13.png)\n\n上述这些改变可以通过 GitHub diff 来查看：\n\n<https://github.com/karanjthakkar/react-native/compare/v0.56.0...rn_lazy_bundle_loading> 🤓\n\n## 在业务代码中进行懒加载\n\n现在我们既有了差分包，也有了加载它的代码，还需要做两件事情将它们封装完善：\n\n**① 将 ScreenB.jsbundle 添加到 XCode 的 bundle 资源下**\n\nreact-native-cli 默认创建的 React Native 项目会把 main.jsbundle 放到 bundle 资源目录下。\n\n由于 ScreenB.jsbundle 是一个非标准的文件，我们需要通过下面配置进行添加：\n\n![](image/ReactNativeLazyBundleLoading14.png)\n\n**② 使用 React Native bridge 实例来触发懒加载**\n\nreact-native-cli 默认创建的 React Native 项目，当我们调用 RCTRootView 的 initWithBundleURL 时会在内部创建 RCTBridge 实例：\n\n![](image/ReactNativeLazyBundleLoading15.png)\n\n在我们的场景中，loadCustomBundle 在 RCTBridge 能够调到。因此我们需要这个类的实例。\n\n为了实现这个，我们将上面实现分为两部分：\n\n![](image/ReactNativeLazyBundleLoading16.png)\n\n在上面的代码中：\n\n- 先创建一个 bridge 实例\n- 使用它创建一个 RCTRootView 实例\n\n按照这种方式我们有了 bridge，现在你可以用它在任何地方加载自定义的 Bundle 了：\n\n ![](image/ReactNativeLazyBundleLoading17.png)\n\n其中：加载名称为 ScreenB 的 bundle，即 ScreenB.jsbundle\n\n你可以将 Bridge 存到一个静态类的属性中，作为一个单例，在任何地方访问。或者你也可以使用依赖注入技术。\n\n关于本文的更加完整详细的示例请参见 [Github](https://github.com/karanjthakkar/RNLazyBundleLoading)。\n\n感谢大家！ 👋🏻 原作者的 Twitter 账号是 [@geekykaran](https://twitter.com/geekykaran)，喜欢的话大家可以去关注他。 \n\n\n\n"},"path":"post/ReactNativeLazyBundleLoadingmd"}
